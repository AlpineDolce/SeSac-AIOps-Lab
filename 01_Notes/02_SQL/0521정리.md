# ğŸ›¢ï¸ SQL ì‹¬í™”: íŠ¸ëœì­ì…˜, ì„±ëŠ¥ ìµœì í™” ë° ì‹¤ë¬´ ì‘ìš© (Day 19)

> **ì´ ë¬¸ì„œì˜ ëª©ì **: ì´ ë¬¸ì„œëŠ” ë¶€íŠ¸ìº í”„ 19ì¼ì°¨ì— í•™ìŠµí•œ SQLì˜ í•µì‹¬ ì‹¬í™” ê¸°ë²•ë“¤ì„ ì²´ê³„ì ìœ¼ë¡œ ì •ë¦¬í•œ ìë£Œì…ë‹ˆë‹¤. **íŠ¸ëœì­ì…˜ ê´€ë¦¬, ì¸ë±ìŠ¤ ìµœì í™”, ì¿¼ë¦¬ ì„±ëŠ¥ íŠœë‹, ê·¸ë¦¬ê³  ì‹¤ì œ ERP ì‹œìŠ¤í…œ ì„¤ê³„ ë° êµ¬í˜„**ì— ì´ë¥´ê¸°ê¹Œì§€, ë°ì´í„°ë² ì´ìŠ¤ë¥¼ í™œìš©í•œ ê²¬ê³ í•˜ê³  íš¨ìœ¨ì ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ê°œë°œ ëŠ¥ë ¥ì„ ë³´ì—¬ì£¼ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤.

---

## ğŸ“š ëª©ì°¨

1.  [**íŠ¸ëœì­ì…˜: ë°ì´í„° ì¼ê´€ì„±ê³¼ ë¬´ê²°ì„± ë³´ì¥**](#1-íŠ¸ëœì­ì…˜-ë°ì´í„°-ì¼ê´€ì„±ê³¼-ë¬´ê²°ì„±-ë³´ì¥)
    -   [1.1. ACID ì›ì¹™: íŠ¸ëœì­ì…˜ì˜ ê¸°ë³¸](#11-acid-ì›ì¹™-íŠ¸ëœì­ì…˜ì˜-ê¸°ë³¸)
        -   [1.1.1. Atomicity (ì›ìì„±): ëª¨ë‘ ì•„ë‹ˆë©´ ì „ë¬´](#111-atomicity-ì›ìì„±-ëª¨ë‘-ì•„ë‹ˆë©´-ì „ë¬´)
        -   [1.1.2. Consistency (ì¼ê´€ì„±): ì œì•½ì¡°ê±´ ìœ ì§€](#112-consistency-ì¼ê´€ì„±-ì œì•½ì¡°ê±´-ìœ ì§€)
    -   [1.2. ê²©ë¦¬ ìˆ˜ì¤€ (Isolation Levels): ë™ì‹œì„± ì œì–´](#12-ê²©ë¦¬-ìˆ˜ì¤€-isolation-levels-ë™ì‹œì„±-ì œì–´)
    -   [1.3. êµì°©ìƒíƒœ (Deadlock): ë°œìƒ ì›ì¸ê³¼ í•´ê²°](#13-êµì°©ìƒíƒœ-deadlock-ë°œìƒ-ì›ì¸ê³¼-í•´ê²°)
2.  [**ì¸ë±ìŠ¤ ìµœì í™” ì „ëµ: ì¿¼ë¦¬ ì„±ëŠ¥ í–¥ìƒ**](#2-ì¸ë±ìŠ¤-ìµœì í™”-ì „ëµ-ì¿¼ë¦¬-ì„±ëŠ¥-í–¥ìƒ)
    -   [2.1. ì¸ë±ìŠ¤ ë¶„ì„ ë° ìµœì í™”](#21-ì¸ë±ìŠ¤-ë¶„ì„-ë°-ìµœì í™”)
    -   [2.2. ì‹¤í–‰ ê³„íš ë¶„ì„](#22-ì‹¤í–‰-ê³„íš-ë¶„ì„)
    -   [2.3. ì¸ë±ìŠ¤ íŒíŠ¸ì™€ ìµœì í™”](#23-ì¸ë±ìŠ¤-íŒíŠ¸ì™€-ìµœì í™”)
3.  [**ì¿¼ë¦¬ ì„±ëŠ¥ íŠœë‹: 10ê°€ì§€ í•µì‹¬ ê¸°ë²•**](#3-ì¿¼ë¦¬-ì„±ëŠ¥-íŠœë‹-10ê°€ì§€-í•µì‹¬-ê¸°ë²•)
    -   [3.1. `SELECT` ì ˆ ìµœì í™”](#31-select-ì ˆ-ìµœì í™”)
    -   [3.2. `WHERE` ì ˆ ìµœì í™”](#32-where-ì ˆ-ìµœì í™”)
    -   [3.3. `JOIN` ìµœì í™”](#33-join-ìµœì í™”)
    -   [3.4. ì„œë¸Œì¿¼ë¦¬ vs `EXISTS` ìµœì í™”](#34-ì„œë¸Œì¿¼ë¦¬-vs-exists-ìµœì í™”)
    -   [3.5. ë¶„í• (Partitioning) ì „ëµ](#35-ë¶„í• partitioning-ì „ëµ)
4.  [**ì‹¤ë¬´ ì¢…í•© í”„ë¡œì íŠ¸: ERP ì‹œìŠ¤í…œ êµ¬ì¶•**](#4-ì‹¤ë¬´-ì¢…í•©-í”„ë¡œì íŠ¸-erp-ì‹œìŠ¤í…œ-êµ¬ì¶•)
    -   [4.1. ì™„ì „í•œ ERP ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„](#41-ì™„ì „í•œ-erp-ë°ì´í„°ë² ì´ìŠ¤-ì„¤ê³„)
    -   [4.2. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ êµ¬í˜„](#42-ë¹„ì¦ˆë‹ˆìŠ¤-ë¡œì§-êµ¬í˜„)
5.  [**ë°±ì—…ê³¼ ë³µì› ì „ëµ: ë°ì´í„° ì•ˆì •ì„± í™•ë³´**](#5-ë°±ì—…ê³¼-ë³µì›-ì „ëµ-ë°ì´í„°-ì•ˆì •ì„±-í™•ë³´)
    -   [5.1. ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ì „ëµ](#51-ë°ì´í„°ë² ì´ìŠ¤-ë°±ì—…-ì „ëµ)
    -   [5.2. ì¬í•´ ë³µêµ¬ ê³„íš](#52-ì¬í•´-ë³µêµ¬-ê³„íš)
6.  [**ìµœì¢… ì„±ê³¼ í‰ê°€: í•™ìŠµ ê²°ê³¼ ê²€ì¦**](#6-ìµœì¢…-ì„±ê³¼-í‰ê°€-í•™ìŠµ-ê²°ê³¼-ê²€ì¦)
    -   [6.1. ì‹œìŠ¤í…œ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬](#61-ì‹œìŠ¤í…œ-ì„±ëŠ¥-ë²¤ì¹˜ë§ˆí¬)
    -   [6.2. í•™ìŠµ ì„±ê³¼ ì²´í¬ë¦¬ìŠ¤íŠ¸](#62-í•™ìŠµ-ì„±ê³¼-ì²´í¬ë¦¬ìŠ¤íŠ¸)
7.  [**ë§ˆë¬´ë¦¬: í•µì‹¬ ì •ë¦¬**](#7-ë§ˆë¬´ë¦¬-í•µì‹¬-ì •ë¦¬)

---

## 1. íŠ¸ëœì­ì…˜: ë°ì´í„° ì¼ê´€ì„±ê³¼ ë¬´ê²°ì„± ë³´ì¥

íŠ¸ëœì­ì…˜(Transaction)ì€ ë°ì´í„°ë² ì´ìŠ¤ì˜ ìƒíƒœë¥¼ ë³€í™”ì‹œí‚¤ëŠ” í•˜ë‚˜ì˜ ë…¼ë¦¬ì ì¸ ì‘ì—… ë‹¨ìœ„ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì€í–‰ ê³„ì¢Œ ì´ì²´ëŠ” 'ì¶œê¸ˆ'ê³¼ 'ì…ê¸ˆ'ì´ë¼ëŠ” ë‘ ê°€ì§€ ì‘ì—…ìœ¼ë¡œ êµ¬ì„±ë˜ì§€ë§Œ, ì´ ë‘ ì‘ì—…ì€ ë°˜ë“œì‹œ í•¨ê»˜ ì„±ê³µí•˜ê±°ë‚˜ í•¨ê»˜ ì‹¤íŒ¨í•´ì•¼ í•©ë‹ˆë‹¤. íŠ¸ëœì­ì…˜ì€ ì´ëŸ¬í•œ ì‘ì—…ì˜ ì¼ê´€ì„±ê³¼ ë¬´ê²°ì„±ì„ ë³´ì¥í•˜ëŠ” í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.

### 1.1. ACID ì›ì¹™: íŠ¸ëœì­ì…˜ì˜ ê¸°ë³¸

ëª¨ë“  íŠ¸ëœì­ì…˜ì€ ë‹¤ìŒ ë„¤ ê°€ì§€ ì†ì„±ì„ ë§Œì¡±í•´ì•¼ í•©ë‹ˆë‹¤. ì´ ì†ì„±ë“¤ì˜ ì• ê¸€ìë¥¼ ë”°ì„œ ACID ì›ì¹™ì´ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤.

#### 1.1.1. Atomicity (ì›ìì„±): ëª¨ë‘ ì•„ë‹ˆë©´ ì „ë¬´

íŠ¸ëœì­ì…˜ ë‚´ì˜ ëª¨ë“  ì—°ì‚°ì€ ì™„ì „íˆ ì„±ê³µí•˜ê±°ë‚˜, ì•„ë‹ˆë©´ ì™„ì „íˆ ì‹¤íŒ¨í•˜ì—¬ ì•„ë¬´ê²ƒë„ ì ìš©ë˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤. ë¶€ë¶„ì ì¸ ì„±ê³µì€ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. `COMMIT`ê³¼ `ROLLBACK`ì„ í†µí•´ ì›ìì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.

```sql
-- ê³„ì¢Œ ì´ì²´ ì‹œë‚˜ë¦¬ì˜¤ (ì›ìì„± ë³´ì¥)
-- í…ŒìŠ¤íŠ¸ìš© ê³„ì¢Œ í…Œì´ë¸” ìƒì„±
CREATE TABLE bank_accounts (
    account_id INT PRIMARY KEY AUTO_INCREMENT,
    account_number VARCHAR(20) UNIQUE NOT NULL,
    customer_name VARCHAR(50) NOT NULL,
    balance DECIMAL(15,2) NOT NULL DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT chk_balance CHECK (balance >= 0)
);

-- ê³„ì¢Œ ì´ì²´ ë¡œê·¸ í…Œì´ë¸”
CREATE TABLE transfer_log (
    transfer_id INT PRIMARY KEY AUTO_INCREMENT,
    from_account VARCHAR(20),
    to_account VARCHAR(20),
    amount DECIMAL(15,2),
    transfer_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'PENDING',
    error_message TEXT
);

-- ìƒ˜í”Œ ê³„ì¢Œ ìƒì„±
INSERT INTO bank_accounts (account_number, customer_name, balance) VALUES
('1001-001', 'ê¹€ì² ìˆ˜', 1000000),
('1001-002', 'ì´ì˜í¬', 500000),
('1001-003', 'ë°•ë¯¼ìˆ˜', 750000);

-- ì›ìì„± ë³´ì¥ ê³„ì¢Œ ì´ì²´ í”„ë¡œì‹œì €
DELIMITER //
CREATE PROCEDURE TransferMoney(
    IN from_account_num VARCHAR(20),
    IN to_account_num VARCHAR(20),
    IN transfer_amount DECIMAL(15,2),
    OUT result_code INT,
    OUT result_message VARCHAR(200)
)
BEGIN
    DECLARE from_balance DECIMAL(15,2);
    DECLARE transfer_id INT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION 
    BEGIN
        -- ì˜¤ë¥˜ ë°œìƒ ì‹œ ë¡¤ë°±
        ROLLBACK;
        SET result_code = -1;
        SET result_message = 'ERROR: ì´ì²´ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
        UPDATE transfer_log SET status = 'FAILED', error_message = 'Transaction failed' 
        WHERE transfer_log.transfer_id = transfer_id;
    END;
    
    -- íŠ¸ëœì­ì…˜ ì‹œì‘
    START TRANSACTION;
    
    -- ì´ì²´ ë¡œê·¸ ê¸°ë¡
    INSERT INTO transfer_log (from_account, to_account, amount) 
    VALUES (from_account_num, to_account_num, transfer_amount);
    SET transfer_id = LAST_INSERT_ID();
    
    -- ì¶œê¸ˆ ê³„ì¢Œ ì”ì•¡ í™•ì¸
    SELECT balance INTO from_balance 
    FROM bank_accounts 
    WHERE account_number = from_account_num FOR UPDATE; -- FOR UPDATEë¡œ ë½ íšë“
    
    IF from_balance < transfer_amount THEN
        SET result_code = -2;
        SET result_message = 'ERROR: ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.';
        UPDATE transfer_log SET status = 'FAILED', error_message = 'Insufficient balance' 
        WHERE transfer_log.transfer_id = transfer_id;
        ROLLBACK;
    ELSE
        -- ì¶œê¸ˆ ì²˜ë¦¬
        UPDATE bank_accounts 
        SET balance = balance - transfer_amount 
        WHERE account_number = from_account_num;
        
        -- ì…ê¸ˆ ì²˜ë¦¬
        UPDATE bank_accounts 
        SET balance = balance + transfer_amount 
        WHERE account_number = to_account_num;
        
        -- ì„±ê³µ ë¡œê·¸ ì—…ë°ì´íŠ¸
        UPDATE transfer_log SET status = 'COMPLETED' 
        WHERE transfer_log.transfer_id = transfer_id;
        
        SET result_code = 0;
        SET result_message = CONCAT('SUCCESS: ', transfer_amount, 'ì›ì´ ì„±ê³µì ìœ¼ë¡œ ì´ì²´ë˜ì—ˆìŠµë‹ˆë‹¤.');
        
        COMMIT;
    END IF;
END //
DELIMITER ;

-- ì´ì²´ í…ŒìŠ¤íŠ¸
SET @code = 0;
SET @msg = '';
CALL TransferMoney('1001-001', '1001-002', 100000, @code, @msg);
SELECT @code AS result_code, @msg AS result_message;
SELECT * FROM bank_accounts;
SELECT * FROM transfer_log;
```

#### 1.1.2. Consistency (ì¼ê´€ì„±): ì œì•½ì¡°ê±´ ìœ ì§€

íŠ¸ëœì­ì…˜ì´ ì‹¤í–‰ë˜ê¸° ì „ê³¼ í›„, ë°ì´í„°ë² ì´ìŠ¤ëŠ” í•­ìƒ ì¼ê´€ëœ ìƒíƒœë¥¼ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” ë°ì´í„°ë² ì´ìŠ¤ì— ì •ì˜ëœ ëª¨ë“  ì œì•½ì¡°ê±´(PRIMARY KEY, FOREIGN KEY, CHECK ë“±)ê³¼ ê·œì¹™ì„ ìœ„ë°˜í•˜ì§€ ì•ŠìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

```sql
-- ì¼ê´€ì„± ê²€ì¦ í”„ë¡œì‹œì €
DELIMITER //
CREATE PROCEDURE ValidateAccountConsistency()
BEGIN
    DECLARE total_balance DECIMAL(15,2);
    DECLARE total_transfers DECIMAL(15,2);
    DECLARE balance_diff DECIMAL(15,2);
    
    -- í˜„ì¬ ì´ ì”ì•¡
    SELECT SUM(balance) INTO total_balance FROM bank_accounts;
    
    -- ì„±ê³µí•œ ì´ì²´ì˜ ì´ì•¡ (ìˆœì¦ê° í™•ì¸)
    SELECT 
        SUM(CASE WHEN status = 'COMPLETED' THEN amount ELSE 0 END) - 
        SUM(CASE WHEN status = 'COMPLETED' THEN amount ELSE 0 END)
    INTO total_transfers 
    FROM transfer_log;
    
    -- ì´ˆê¸° ì”ì•¡ê³¼ í˜„ì¬ ì”ì•¡ ë¹„êµ (ì¼ê´€ì„± í™•ì¸)
    SELECT 
        total_balance AS current_total_balance,
        1500000 AS initial_total_balance,  -- ì´ˆê¸° ì´ ì”ì•¡ (ìƒ˜í”Œ ë°ì´í„°ì˜ í•©ê³„)
        total_balance - 1500000 AS balance_difference,
        CASE 
            WHEN ABS(total_balance - 1500000) < 0.01 THEN 'CONSISTENT'
            ELSE 'INCONSISTENT'
        END AS consistency_status;
END //
DELIMITER ;

CALL ValidateAccountConsistency();
```

### 1.2. ê²©ë¦¬ ìˆ˜ì¤€ (Isolation Levels): ë™ì‹œì„± ì œì–´

ì—¬ëŸ¬ íŠ¸ëœì­ì…˜ì´ ë™ì‹œì— ì‹¤í–‰ë  ë•Œ, ê° íŠ¸ëœì­ì…˜ì´ ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì˜ ë³€ê²½ ë‚´ìš©ì„ ì–¼ë§ˆë‚˜ ë³¼ ìˆ˜ ìˆëŠ”ì§€ë¥¼ ì •ì˜í•˜ëŠ” ê²ƒì´ ê²©ë¦¬ ìˆ˜ì¤€ì…ë‹ˆë‹¤. ANSI/ISO SQL í‘œì¤€ì€ ë„¤ ê°€ì§€ ê²©ë¦¬ ìˆ˜ì¤€ì„ ì •ì˜í•©ë‹ˆë‹¤. ê²©ë¦¬ ìˆ˜ì¤€ì´ ë†’ì„ìˆ˜ë¡ ë™ì‹œì„±ì€ ë–¨ì–´ì§€ì§€ë§Œ ë°ì´í„° ì¼ê´€ì„±ì€ ë†’ì•„ì§‘ë‹ˆë‹¤.

-   **`READ UNCOMMITTED`**: ì»¤ë°‹ë˜ì§€ ì•Šì€(Dirty) ë°ì´í„°ë¥¼ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. Dirty Read, Non-Repeatable Read, Phantom Read ë°œìƒ ê°€ëŠ¥.
-   **`READ COMMITTED`**: ì»¤ë°‹ëœ ë°ì´í„°ë§Œ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. Dirty ReadëŠ” ë°©ì§€ë˜ì§€ë§Œ, Non-Repeatable Read, Phantom Read ë°œìƒ ê°€ëŠ¥.
-   **`REPEATABLE READ`**: íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ ë™ì¼í•œ ë°ì´í„°ë¥¼ ì—¬ëŸ¬ ë²ˆ ì½ì–´ë„ í•­ìƒ ê°™ì€ ê²°ê³¼ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤. Dirty Read, Non-Repeatable ReadëŠ” ë°©ì§€ë˜ì§€ë§Œ, Phantom Read ë°œìƒ ê°€ëŠ¥. (MySQLì˜ ê¸°ë³¸ ê²©ë¦¬ ìˆ˜ì¤€)
-   **`SERIALIZABLE`**: ê°€ì¥ ì—„ê²©í•œ ê²©ë¦¬ ìˆ˜ì¤€ìœ¼ë¡œ, ëª¨ë“  ì¢…ë¥˜ì˜ ì½ê¸°/ì“°ê¸° ì´ìƒ í˜„ìƒì„ ë°©ì§€í•©ë‹ˆë‹¤. ë™ì‹œì„±ì´ ê°€ì¥ ë‚®ìŠµë‹ˆë‹¤.

```sql
-- í˜„ì¬ ê²©ë¦¬ ìˆ˜ì¤€ í™•ì¸
SELECT @@transaction_isolation;

-- ê²©ë¦¬ ìˆ˜ì¤€ë³„ í…ŒìŠ¤íŠ¸ìš© ì„¸ì…˜ ì„¤ì •
-- SESSION 1 (í„°ë¯¸ë„ 1ì—ì„œ ì‹¤í–‰)
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
UPDATE bank_accounts SET balance = balance + 1000000 WHERE account_number = '1001-001';
-- ì•„ì§ COMMIT í•˜ì§€ ì•ŠìŒ

-- SESSION 2 (í„°ë¯¸ë„ 2ì—ì„œ ì‹¤í–‰)
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
START TRANSACTION;
SELECT * FROM bank_accounts WHERE account_number = '1001-001';  -- Dirty Read ë°œìƒ ê°€ëŠ¥

-- READ COMMITTED í…ŒìŠ¤íŠ¸
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
START TRANSACTION;
SELECT * FROM bank_accounts WHERE account_number = '1001-001';  -- ì»¤ë°‹ëœ ë°ì´í„°ë§Œ ì½ìŒ

-- REPEATABLE READ í…ŒìŠ¤íŠ¸ (MySQL ê¸°ë³¸ê°’)
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
START TRANSACTION;
SELECT * FROM bank_accounts WHERE account_number = '1001-001';
-- ë‹¤ë¥¸ ì„¸ì…˜ì—ì„œ UPDATE í›„ COMMIT
SELECT * FROM bank_accounts WHERE account_number = '1001-001';  -- ë™ì¼í•œ ê²°ê³¼

-- SERIALIZABLE í…ŒìŠ¤íŠ¸ (ê°€ì¥ ì—„ê²©)
SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
SELECT * FROM bank_accounts WHERE account_number = '1001-001';
-- ë‹¤ë¥¸ ì„¸ì…˜ì˜ ìˆ˜ì • ì‘ì—…ì´ ëŒ€ê¸°ë¨
```

### 1.3. êµì°©ìƒíƒœ (Deadlock): ë°œìƒ ì›ì¸ê³¼ í•´ê²°

êµì°©ìƒíƒœ(Deadlock)ëŠ” ë‘ ê°œ ì´ìƒì˜ íŠ¸ëœì­ì…˜ì´ ì„œë¡œê°€ ì ìœ í•˜ê³  ìˆëŠ” ìì›ì„ ê¸°ë‹¤ë¦¬ë©´ì„œ ë¬´í•œì • ëŒ€ê¸°í•˜ëŠ” ìƒíƒœë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ ì‹œìŠ¤í…œì€ êµì°©ìƒíƒœë¥¼ ê°ì§€í•˜ê³ , ì¼ë°˜ì ìœ¼ë¡œ í•˜ë‚˜ì˜ íŠ¸ëœì­ì…˜ì„ ê°•ì œë¡œ ì¢…ë£Œ(Rollback)ì‹œì¼œ ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì´ ì§„í–‰ë  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.

**ì£¼ìš” ë°œìƒ ì›ì¸**: íŠ¸ëœì­ì…˜ë“¤ì´ ì„œë¡œ ë‹¤ë¥¸ ìˆœì„œë¡œ ìì›(í–‰, í…Œì´ë¸” ë“±)ì— ë½(Lock)ì„ íšë“í•˜ë ¤ í•  ë•Œ ë°œìƒí•©ë‹ˆë‹¤.

**í•´ê²° ë°©ì•ˆ**: ì¼ê´€ëœ ë½ ìˆœì„œ(Locking Order)ë¥¼ ìœ ì§€í•˜ëŠ” ê²ƒì´ ê°€ì¥ ì¤‘ìš”í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, í•­ìƒ ê³„ì¢Œ ë²ˆí˜¸ê°€ ì‘ì€ ìˆœì„œëŒ€ë¡œ ë½ì„ íšë“í•˜ë„ë¡ ê·œì¹™ì„ ì •í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

```sql
-- êµì°©ìƒíƒœ ëª¨ë‹ˆí„°ë§ í…Œì´ë¸”
CREATE TABLE deadlock_log (
    log_id INT PRIMARY KEY AUTO_INCREMENT,
    session_id VARCHAR(50),
    query_text TEXT,
    lock_wait_time DECIMAL(10,3),
    deadlock_occurred BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- êµì°©ìƒíƒœ ë°©ì§€ í”„ë¡œì‹œì € (ì¼ê´€ëœ ë½ ìˆœì„œ)
DELIMITER //
CREATE PROCEDURE SafeTransferBetweenAccounts(
    IN account1 VARCHAR(20),
    IN account2 VARCHAR(20),
    IN amount1 DECIMAL(15,2),
    IN amount2 DECIMAL(15,2)
)
BEGIN
    DECLARE first_account VARCHAR(20);
    DECLARE second_account VARCHAR(20);
    DECLARE first_amount DECIMAL(15,2);
    DECLARE second_amount DECIMAL(15,2);
    
    -- êµì°©ìƒíƒœ ë°©ì§€ë¥¼ ìœ„í•œ ì¼ê´€ëœ ë½ ìˆœì„œ (ê³„ì¢Œë²ˆí˜¸ ìˆœì„œëŒ€ë¡œ ì •ë ¬)
    IF account1 < account2 THEN
        SET first_account = account1;
        SET second_account = account2;
        SET first_amount = amount1;
        SET second_amount = amount2;
    ELSE
        SET first_account = account2;
        SET second_account = account1;
        SET first_amount = amount2;
        SET second_amount = amount1;
    END IF;
    
    START TRANSACTION;
    
    -- ì¼ê´€ëœ ìˆœì„œë¡œ ë½ íšë“ (ê³„ì¢Œë²ˆí˜¸ê°€ ì‘ì€ ê³„ì¢Œë¶€í„° ì—…ë°ì´íŠ¸)
    UPDATE bank_accounts SET balance = balance + first_amount 
    WHERE account_number = first_account;
    
    UPDATE bank_accounts SET balance = balance + second_amount 
    WHERE account_number = second_account;
    
    COMMIT;
END //
DELIMITER ;

-- êµì°©ìƒíƒœ ê°ì§€ ì¿¼ë¦¬ (MySQL information_schema í™œìš©)
SELECT 
    r.trx_id waiting_trx_id,
    r.trx_mysql_thread_id waiting_thread,
    r.trx_query waiting_query,
    b.trx_id blocking_trx_id,
    b.trx_mysql_thread_id blocking_thread,
    b.trx_query blocking_query
FROM information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```

---

## 2. ì¸ë±ìŠ¤ ìµœì í™” ì „ëµ: ì¿¼ë¦¬ ì„±ëŠ¥ í–¥ìƒ

ì¸ë±ìŠ¤(Index)ëŠ” ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸”ì˜ íŠ¹ì • ì—´ì— ëŒ€í•œ ê²€ìƒ‰ ì†ë„ë¥¼ ë†’ì´ê¸° ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ì ì ˆí•œ ì¸ë±ìŠ¤ ì „ëµì€ ëŒ€ìš©ëŸ‰ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¿¼ë¦¬ ì„±ëŠ¥ì„ íšê¸°ì ìœ¼ë¡œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 2.1. ì¸ë±ìŠ¤ ë¶„ì„ ë° ìµœì í™”

ì¸ë±ìŠ¤ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•˜ë ¤ë©´ í˜„ì¬ ì¸ë±ìŠ¤ì˜ í˜„í™©ê³¼ ê° ì¸ë±ìŠ¤ì˜ ì„ íƒë„(Cardinality)ë¥¼ ë¶„ì„í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤. ì„ íƒë„ê°€ ë†’ì„ìˆ˜ë¡(ì¤‘ë³µë˜ëŠ” ê°’ì´ ì ì„ìˆ˜ë¡) ì¸ë±ìŠ¤ì˜ íš¨ìœ¨ì´ ì¢‹ìŠµë‹ˆë‹¤.

#### í˜„ì¬ ì¸ë±ìŠ¤ í˜„í™© ë¶„ì„
```sql
-- ì¸ë±ìŠ¤ ì‚¬ìš© í˜„í™© ë¶„ì„
SELECT 
    t.TABLE_NAME,
    t.TABLE_ROWS,
    ROUND(((t.DATA_LENGTH + t.INDEX_LENGTH) / 1024 / 1024), 2) AS 'Table Size (MB)',
    ROUND((t.INDEX_LENGTH / 1024 / 1024), 2) AS 'Index Size (MB)',
    ROUND((t.INDEX_LENGTH / (t.DATA_LENGTH + t.INDEX_LENGTH)) * 100, 2) AS 'Index Ratio (%)',
    s.INDEX_NAME,
    s.COLUMN_NAME,
    s.CARDINALITY
FROM information_schema.TABLES t
LEFT JOIN information_schema.STATISTICS s ON t.TABLE_NAME = s.TABLE_NAME
WHERE t.TABLE_SCHEMA = DATABASE()
  AND t.TABLE_TYPE = 'BASE TABLE'
ORDER BY t.TABLE_NAME, s.SEQ_IN_INDEX;

-- ì¸ë±ìŠ¤ íš¨ìœ¨ì„± ë¶„ì„
SELECT 
    INDEX_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    CARDINALITY,
    CASE 
        WHEN CARDINALITY IS NULL THEN 'No statistics'
        WHEN CARDINALITY < 10 THEN 'Low selectivity - Consider removal'
        WHEN CARDINALITY > 1000 THEN 'High selectivity - Good'
        ELSE 'Medium selectivity'
    END AS selectivity_assessment
FROM information_schema.STATISTICS 
WHERE TABLE_SCHEMA = DATABASE()
ORDER BY CARDINALITY DESC;
```

#### ë³µí•© ì¸ë±ìŠ¤ ìµœì í™”

ë³µí•© ì¸ë±ìŠ¤(Composite Index)ëŠ” ë‘ ê°œ ì´ìƒì˜ ì—´ì„ ì¡°í•©í•˜ì—¬ ìƒì„±ëœ ì¸ë±ìŠ¤ì…ë‹ˆë‹¤. `WHERE` ì ˆì— ì—¬ëŸ¬ ì¡°ê±´ì´ í•¨ê»˜ ì‚¬ìš©ë˜ê±°ë‚˜ `ORDER BY` ì ˆì— ì—¬ëŸ¬ ì—´ì´ ì‚¬ìš©ë  ë•Œ íš¨ê³¼ì ì…ë‹ˆë‹¤. ë³µí•© ì¸ë±ìŠ¤ì˜ ì—´ ìˆœì„œëŠ” ë§¤ìš° ì¤‘ìš”í•˜ë©°, ì¿¼ë¦¬ì˜ `WHERE` ì ˆì— ì‚¬ìš©ë˜ëŠ” ì—´ì„ ì¸ë±ìŠ¤ì˜ ì„ ë‘ì— ë‘ëŠ” ê²ƒì´ ì¼ë°˜ì ì¸ ì „ëµì…ë‹ˆë‹¤.

```sql
-- ì¿¼ë¦¬ íŒ¨í„´ ë¶„ì„ì„ ìœ„í•œ ë³µí•© ì¸ë±ìŠ¤ ìƒì„±
-- 1. ë¶€ì„œ + ê¸‰ì—¬ ì¡°íšŒ íŒ¨í„´
CREATE INDEX idx_dept_salary_hire ON employees(department, salary, hire_date);

-- 2. í”„ë¡œì íŠ¸ + ì§ì› + ë‚ ì§œ íŒ¨í„´
CREATE INDEX idx_project_emp_dates ON project_assignments(project_id, emp_id, start_date, end_date);

-- 3. ê¸‰ì—¬ ì´ë ¥ ì¡°íšŒ íŒ¨í„´
CREATE INDEX idx_salary_emp_date ON salary_history(emp_id, change_date);

-- ì¸ë±ìŠ¤ ì‚¬ìš© íš¨ê³¼ ë¹„êµ
EXPLAIN FORMAT=JSON
SELECT e.name, e.salary, e.hire_date
FROM employees e
WHERE e.department = 'ê°œë°œíŒ€' 
  AND e.salary > 4000000
  AND e.hire_date >= '2024-01-01'
ORDER BY e.salary DESC;

-- ì»¤ë²„ë§ ì¸ë±ìŠ¤ ìƒì„± (ë°ì´í„°ê¹Œì§€ í¬í•¨)
-- ì»¤ë²„ë§ ì¸ë±ìŠ¤ëŠ” ì¿¼ë¦¬ì— í•„ìš”í•œ ëª¨ë“  ì—´ì´ ì¸ë±ìŠ¤ ìì²´ì— í¬í•¨ë˜ì–´ ìˆì–´, í…Œì´ë¸”ì— ì ‘ê·¼í•  í•„ìš” ì—†ì´ ì¸ë±ìŠ¤ë§Œìœ¼ë¡œ ì¿¼ë¦¬ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.
CREATE INDEX idx_covering_employee_summary ON employees(department, salary, name, hire_date);

-- ì»¤ë²„ë§ ì¸ë±ìŠ¤ íš¨ê³¼ í™•ì¸
EXPLAIN FORMAT=JSON
SELECT name, salary, hire_date
FROM employees
WHERE department = 'ê°œë°œíŒ€' AND salary > 4000000;
```

### 2.2. ì‹¤í–‰ ê³„íš ë¶„ì„

ì¿¼ë¦¬ ì‹¤í–‰ ê³„íš(Execution Plan)ì€ ë°ì´í„°ë² ì´ìŠ¤ ì˜µí‹°ë§ˆì´ì €ê°€ íŠ¹ì • ì¿¼ë¦¬ë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•´ ì–´ë–¤ ë‹¨ê³„ë¥¼ ê±°ì¹ ì§€ ë³´ì—¬ì£¼ëŠ” ë¡œë“œë§µì…ë‹ˆë‹¤. `EXPLAIN` ëª…ë ¹ì–´ë¥¼ í†µí•´ ì‹¤í–‰ ê³„íšì„ ë¶„ì„í•˜ì—¬ ì¿¼ë¦¬ ì„±ëŠ¥ì˜ ë³‘ëª© ì§€ì ì„ íŒŒì•…í•˜ê³  ìµœì í™” ë°©ì•ˆì„ ëª¨ìƒ‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### ì¿¼ë¦¬ ì„±ëŠ¥ ë¶„ì„ ë„êµ¬
```sql
-- 1. ì‹¤í–‰ ê³„íš ìƒì„¸ ë¶„ì„
EXPLAIN FORMAT=JSON
SELECT 
    e.name,
    d.dept_name,
    p.project_name,
    pa.allocation_percent
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id
INNER JOIN project_assignments pa ON e.emp_id = pa.emp_id
INNER JOIN projects p ON pa.project_id = p.project_id
WHERE e.salary > 4500000
  AND p.status = 'In Progress'
ORDER BY e.salary DESC
LIMIT 10;

-- 2. ì¿¼ë¦¬ í”„ë¡œíŒŒì¼ë§ í™œì„±í™”
-- í”„ë¡œíŒŒì¼ë§ì€ ì¿¼ë¦¬ ì‹¤í–‰ ì¤‘ ê° ë‹¨ê³„ì—ì„œ ì†Œìš”ëœ ì‹œê°„ê³¼ ìì› ì‚¬ìš©ëŸ‰ì„ ìƒì„¸í•˜ê²Œ ê¸°ë¡í•©ë‹ˆë‹¤.
SET profiling = 1;

-- ë¶„ì„í•  ì¿¼ë¦¬ ì‹¤í–‰
SELECT COUNT(*) FROM employees e
WHERE EXISTS (
    SELECT 1 FROM project_assignments pa 
    WHERE pa.emp_id = e.emp_id
);

-- í”„ë¡œíŒŒì¼ ê²°ê³¼ í™•ì¸
SHOW PROFILES;
SHOW PROFILE FOR QUERY 1; -- íŠ¹ì • ì¿¼ë¦¬ IDì— ëŒ€í•œ ìƒì„¸ í”„ë¡œíŒŒì¼

-- 3. ì„±ëŠ¥ ìŠ¤í‚¤ë§ˆ í™œìš©
-- MySQL Performance SchemaëŠ” ì„œë²„ì˜ ì €ìˆ˜ì¤€ ì´ë²¤íŠ¸(SQL ì‹¤í–‰, ë½, I/O ë“±)ì— ëŒ€í•œ ìƒì„¸ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
SELECT 
    EVENT_NAME,
    COUNT_STAR,
    SUM_TIMER_WAIT/1000000000000 AS total_time_sec, -- ë‚˜ë…¸ì´ˆë¥¼ ì´ˆë¡œ ë³€í™˜
    AVG_TIMER_WAIT/1000000000000 AS avg_time_sec
FROM performance_schema.events_statements_summary_by_event_name
WHERE EVENT_NAME LIKE 'statement/sql/%'
ORDER BY SUM_TIMER_WAIT DESC
LIMIT 10;
```

### 2.3. ì¸ë±ìŠ¤ íŒíŠ¸ì™€ ìµœì í™”

ë°ì´í„°ë² ì´ìŠ¤ ì˜µí‹°ë§ˆì´ì €ëŠ” ì¿¼ë¦¬ ì‹¤í–‰ ê³„íšì„ ìë™ìœ¼ë¡œ ì„ íƒí•˜ì§€ë§Œ, ë•Œë¡œëŠ” ê°œë°œìê°€ íŠ¹ì • ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ê°•ì œí•˜ê±°ë‚˜ JOIN ìˆœì„œë¥¼ ì§€ì •í•˜ì—¬ ì„±ëŠ¥ì„ ê°œì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ì˜µí‹°ë§ˆì´ì €ì˜ ì„ íƒì´ ìµœì ì´ ì•„ë‹ ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

#### ğŸ¯ ì¸ë±ìŠ¤ íŒíŠ¸ í™œìš©
```sql
-- 1. íŠ¹ì • ì¸ë±ìŠ¤ ê°•ì œ ì‚¬ìš© (USE_INDEX, FORCE_INDEX)
SELECT /*+ USE_INDEX(employees, idx_dept_salary_hire) */
    name, department, salary
FROM employees
WHERE department = 'ê°œë°œíŒ€' AND salary > 4000000;

-- 2. ì¸ë±ìŠ¤ ë¬´ì‹œ (IGNORE_INDEX) (í…ŒìŠ¤íŠ¸ ëª©ì )
SELECT /*+ IGNORE_INDEX(employees, idx_dept_salary_hire) */
    name, department, salary
FROM employees
WHERE department = 'ê°œë°œíŒ€' AND salary > 4000000;

-- 3. ì¡°ì¸ ìˆœì„œ ìµœì í™” (STRAIGHT_JOIN)
-- STRAIGHT_JOINì€ FROM ì ˆì— ëª…ì‹œëœ ìˆœì„œëŒ€ë¡œ í…Œì´ë¸”ì„ ì¡°ì¸í•˜ë„ë¡ ê°•ì œí•©ë‹ˆë‹¤.
SELECT /*+ STRAIGHT_JOIN */
    e.name, d.dept_name, p.project_name
FROM departments d
INNER JOIN employees e ON d.dept_id = e.dept_id
INNER JOIN project_assignments pa ON e.emp_id = pa.emp_id
INNER JOIN projects p ON pa.project_id = p.project_id
WHERE d.budget > 30000000;
```

---


## 3. ì¿¼ë¦¬ ì„±ëŠ¥ íŠœë‹: 10ê°€ì§€ í•µì‹¬ ê¸°ë²•

ì¿¼ë¦¬ íŠœë‹ì€ ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ ìµœì í™”ì˜ í•µì‹¬ì…ë‹ˆë‹¤. ë™ì¼í•œ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” ì¿¼ë¦¬ë¼ë„ ì‘ì„± ë°©ì‹ì— ë”°ë¼ ì„±ëŠ¥ ì°¨ì´ê°€ í¬ê²Œ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒì€ ì¿¼ë¦¬ ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¤ê¸° ìœ„í•œ ì£¼ìš” ê¸°ë²•ë“¤ì…ë‹ˆë‹¤.

### 3.1. `SELECT` ì ˆ ìµœì í™”

`SELECT *` ëŒ€ì‹  í•„ìš”í•œ ì—´ë§Œ ëª…ì‹œí•˜ì—¬ ë„¤íŠ¸ì›Œí¬ íŠ¸ë˜í”½ê³¼ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì…ë‹ˆë‹¤. íŠ¹íˆ ëŒ€ìš©ëŸ‰ í…Œì´ë¸”ì—ì„œ ë¶ˆí•„ìš”í•œ ì—´ì„ ê°€ì ¸ì˜¤ëŠ” ê²ƒì€ ì„±ëŠ¥ ì €í•˜ì˜ ì£¼ìš” ì›ì¸ì…ë‹ˆë‹¤.

```sql
-- âŒ ë¹„íš¨ìœ¨ì ì¸ ì¿¼ë¦¬: ëª¨ë“  ì»¬ëŸ¼ì„ ê°€ì ¸ì˜´
SELECT * FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 4000000;

-- âœ… ìµœì í™”ëœ ì¿¼ë¦¬: í•„ìš”í•œ ì»¬ëŸ¼ë§Œ ëª…ì‹œ
SELECT e.name, e.salary, d.dept_name
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 4000000;
```

### 3.2. `WHERE` ì ˆ ìµœì í™”

`WHERE` ì ˆì€ ì¿¼ë¦¬ì—ì„œ ê°€ì¥ ë¨¼ì € ì‹¤í–‰ë˜ëŠ” ë¶€ë¶„ ì¤‘ í•˜ë‚˜ì´ë¯€ë¡œ, íš¨ìœ¨ì ì¸ `WHERE` ì ˆì€ ì¿¼ë¦¬ ì„±ëŠ¥ì— í° ì˜í–¥ì„ ë¯¸ì¹©ë‹ˆë‹¤. ì¸ë±ìŠ¤ë¥¼ í™œìš©í•  ìˆ˜ ìˆë„ë¡ ì¡°ê±´ì„ ì‘ì„±í•˜ê³ , `OR` ì¡°ê±´ ëŒ€ì‹  `IN`ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

```sql
-- âŒ í•¨ìˆ˜ ì‚¬ìš©ìœ¼ë¡œ ì¸ë±ìŠ¤ ë¬´íš¨í™”: YEAR() í•¨ìˆ˜ê°€ hire_date ì»¬ëŸ¼ì— ì ìš©ë˜ì–´ ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ê²Œ ë§Œë“¬
SELECT * FROM employees WHERE YEAR(hire_date) = 2024;

-- âœ… ë²”ìœ„ ì¡°ê±´ìœ¼ë¡œ ì¸ë±ìŠ¤ í™œìš©: hire_date ì»¬ëŸ¼ì— ì§ì ‘ì ì¸ ë²”ìœ„ ì¡°ê±´ì„ ì‚¬ìš©í•˜ì—¬ ì¸ë±ìŠ¤ í™œìš© ê°€ëŠ¥
SELECT * FROM employees 
WHERE hire_date >= '2024-01-01' AND hire_date < '2025-01-01';

-- âŒ OR ì¡°ê±´ìœ¼ë¡œ ì¸ë±ìŠ¤ íš¨ìœ¨ì„± ì €í•˜: OR ì¡°ê±´ì€ ì¸ë±ìŠ¤ ì‚¬ìš©ì„ ì–´ë µê²Œ í•˜ê±°ë‚˜ ì—¬ëŸ¬ ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ê²Œ í•˜ì—¬ ë¹„íš¨ìœ¨ì ì¼ ìˆ˜ ìˆìŒ
SELECT * FROM employees WHERE department = 'ê°œë°œíŒ€' OR department = 'ë””ìì¸íŒ€';

-- âœ… IN ì¡°ê±´ìœ¼ë¡œ ìµœì í™”: IN ì¡°ê±´ì€ ì—¬ëŸ¬ OR ì¡°ê±´ì„ ëŒ€ì²´í•˜ë©°, ì˜µí‹°ë§ˆì´ì €ê°€ ë” íš¨ìœ¨ì ì¸ ì‹¤í–‰ ê³„íšì„ ì„¸ìš¸ ìˆ˜ ìˆë„ë¡ ë„ì›€
SELECT * FROM employees WHERE department IN ('ê°œë°œíŒ€', 'ë””ìì¸íŒ€');
```

### 3.3. `JOIN` ìµœì í™”

`JOIN`ì€ ì—¬ëŸ¬ í…Œì´ë¸”ì„ ì—°ê²°í•˜ëŠ” ì‘ì—…ì´ë¯€ë¡œ, `JOIN` ìˆœì„œì™€ ì¡°ê±´ì— ë”°ë¼ ì„±ëŠ¥ì´ í¬ê²Œ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œëŠ” í•„í„°ë§ ì¡°ê±´ì´ ê°•í•œ í…Œì´ë¸”ì„ ë¨¼ì € ì¡°ì¸í•˜ê±°ë‚˜, ì‘ì€ í…Œì´ë¸”ë¶€í„° ì¡°ì¸í•˜ëŠ” ê²ƒì´ ìœ ë¦¬í•©ë‹ˆë‹¤.

```sql
-- ì‘ì€ í…Œì´ë¸”ë¶€í„° ì¡°ì¸í•˜ëŠ” ìµœì í™”ëœ ì¿¼ë¦¬
EXPLAIN FORMAT=JSON
SELECT 
    d.dept_name,
    COUNT(e.emp_id) as employee_count,
    AVG(e.salary) as avg_salary
FROM departments d  -- ì‘ì€ í…Œì´ë¸”ë¶€í„°
LEFT JOIN employees e ON d.dept_id = e.dept_id
WHERE d.budget > 25000000  -- ì„ íƒì  ì¡°ê±´ ë¨¼ì €
GROUP BY d.dept_id, d.dept_name
HAVING COUNT(e.emp_id) > 0
ORDER BY avg_salary DESC;
```

### 3.4. ì„œë¸Œì¿¼ë¦¬ vs `EXISTS` ìµœì í™”

`IN` ì ˆì„ ì‚¬ìš©í•˜ëŠ” ì„œë¸Œì¿¼ë¦¬ë³´ë‹¤ `JOIN`ì´ë‚˜ `EXISTS`ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ëŒ€ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì‹œ ì„±ëŠ¥ìƒ ìœ ë¦¬í•œ ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤. `EXISTS`ëŠ” ì„œë¸Œì¿¼ë¦¬ì—ì„œ ì¡°ê±´ì— ë§ëŠ” í–‰ì„ í•˜ë‚˜ë¼ë„ ì°¾ìœ¼ë©´ ë” ì´ìƒ ê²€ìƒ‰í•˜ì§€ ì•Šê³  `TRUE`ë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ íš¨ìœ¨ì ì…ë‹ˆë‹¤.

```sql
-- ì„±ëŠ¥ ë¹„êµìš© ëŒ€ìš©ëŸ‰ ë°ì´í„° ìƒì„± í”„ë¡œì‹œì €
DELIMITER //
CREATE PROCEDURE GenerateLargeDataset()
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE random_dept INT;
    DECLARE random_salary INT;
    
    -- ëŒ€ìš©ëŸ‰ í…ŒìŠ¤íŠ¸ í…Œì´ë¸” ìƒì„±
    DROP TABLE IF EXISTS large_employees;
    CREATE TABLE large_employees (
        emp_id INT PRIMARY KEY AUTO_INCREMENT,
        name VARCHAR(50),
        department VARCHAR(30),
        salary DECIMAL(10,2),
        hire_date DATE,
        INDEX idx_dept (department),
        INDEX idx_salary (salary)
    );
    
    WHILE i <= 100000 DO
        SET random_dept = FLOOR(RAND() * 5) + 1;
        SET random_salary = FLOOR(RAND() * 5000000) + 3000000;
        
        INSERT INTO large_employees (name, department, salary, hire_date)
        VALUES (
            CONCAT('Employee_', i),
            CASE random_dept
                WHEN 1 THEN 'ê°œë°œíŒ€'
                WHEN 2 THEN 'ë§ˆì¼€íŒ…íŒ€'
                WHEN 3 THEN 'ë””ìì¸íŒ€'
                WHEN 4 THEN 'ì˜ì—…íŒ€'
                ELSE 'ì¸ì‚¬íŒ€'
            END,
            random_salary,
            DATE_ADD('2020-01-01', INTERVAL FLOOR(RAND() * 1500) DAY)
        );
        
        SET i = i + 1;
    END WHILE;
END //
DELIMITER ;

-- CALL GenerateLargeDataset();  -- ì‹¤í–‰ ì‹œ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦¼

-- ì„œë¸Œì¿¼ë¦¬ vs EXISTS ì„±ëŠ¥ ë¹„êµ
-- âŒ ëŠë¦° ì„œë¸Œì¿¼ë¦¬ (IN ì‚¬ìš©): ì„œë¸Œì¿¼ë¦¬ê°€ ëª¨ë“  ê²°ê³¼ë¥¼ ë°˜í™˜í•œ í›„ ì™¸ë¶€ ì¿¼ë¦¬ì™€ ë¹„êµ
SELECT name, salary FROM large_employees
WHERE department IN (
    SELECT dept_name FROM departments WHERE budget > 30000000
);

-- âœ… ë¹ ë¥¸ EXISTS ì‚¬ìš©: ì¡°ê±´ì— ë§ëŠ” ì²« ë²ˆì§¸ í–‰ì„ ì°¾ìœ¼ë©´ ì¦‰ì‹œ TRUE ë°˜í™˜
SELECT name, salary FROM large_employees le
WHERE EXISTS (
    SELECT 1 FROM departments d 
    WHERE d.dept_name = le.department AND d.budget > 30000000
);
```

### 3.5. ë¶„í• (Partitioning) ì „ëµ

í…Œì´ë¸” ë¶„í• (Partitioning)ì€ ëŒ€ìš©ëŸ‰ í…Œì´ë¸”ì„ ë” ì‘ê³  ê´€ë¦¬í•˜ê¸° ì‰¬ìš´ ì—¬ëŸ¬ ê°œì˜ ë…¼ë¦¬ì ì¸ ë¶€ë¶„(íŒŒí‹°ì…˜)ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ê¸°ë²•ì…ë‹ˆë‹¤. íŠ¹ì • ë²”ìœ„ì˜ ë°ì´í„°ë¥¼ ì¡°íšŒí•  ë•Œ ì „ì²´ í…Œì´ë¸”ì„ ìŠ¤ìº”í•˜ì§€ ì•Šê³  í•´ë‹¹ íŒŒí‹°ì…˜ë§Œ ìŠ¤ìº”í•˜ì—¬ ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### í…Œì´ë¸” íŒŒí‹°ì…”ë‹
```sql
-- ë‚ ì§œ ê¸°ë°˜ íŒŒí‹°ì…”ë‹ (ê¸‰ì—¬ ì´ë ¥ í…Œì´ë¸”)
CREATE TABLE salary_history_partitioned (
    history_id INT AUTO_INCREMENT,
    emp_id INT NOT NULL,
    old_salary DECIMAL(10,2),
    new_salary DECIMAL(10,2),
    change_date DATE NOT NULL,
    change_reason VARCHAR(100),
    PRIMARY KEY (history_id, change_date) -- íŒŒí‹°ì…˜ í‚¤ê°€ PRIMARY KEYì— í¬í•¨ë˜ì–´ì•¼ í•¨
) PARTITION BY RANGE (YEAR(change_date)) ( -- change_dateì˜ ì—°ë„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ íŒŒí‹°ì…˜
    PARTITION p2020 VALUES LESS THAN (2021), -- 2020ë…„ ë°ì´í„°
    PARTITION p2021 VALUES LESS THAN (2022), -- 2021ë…„ ë°ì´í„°
    PARTITION p2022 VALUES LESS THAN (2023), -- 2022ë…„ ë°ì´í„°
    PARTITION p2023 VALUES LESS THAN (2024), -- 2023ë…„ ë°ì´í„°
    PARTITION p2024 VALUES LESS THAN (2025), -- 2024ë…„ ë°ì´í„°
    PARTITION p_future VALUES LESS THAN MAXVALUE -- 2025ë…„ ì´í›„ ë°ì´í„°
);

-- íŒŒí‹°ì…˜ ì •ë³´ í™•ì¸
SELECT 
    PARTITION_NAME,
    TABLE_ROWS,
    PARTITION_EXPRESSION,
    PARTITION_DESCRIPTION
FROM information_schema.PARTITIONS
WHERE TABLE_NAME = 'salary_history_partitioned';

-- íŒŒí‹°ì…˜ í”„ë£¨ë‹(Pruning) íš¨ê³¼ í™•ì¸
-- íŒŒí‹°ì…˜ í”„ë£¨ë‹ì€ ì¿¼ë¦¬ ì¡°ê±´ì— ë”°ë¼ í•„ìš”í•œ íŒŒí‹°ì…˜ë§Œ ìŠ¤ìº”í•˜ëŠ” ìµœì í™” ê¸°ë²•ì…ë‹ˆë‹¤.
EXPLAIN PARTITIONS
SELECT * FROM salary_history_partitioned
WHERE change_date BETWEEN '2024-01-01' AND '2024-12-31'; -- 2024ë…„ íŒŒí‹°ì…˜ë§Œ ìŠ¤ìº”
```

---

## 4. ì‹¤ë¬´ ì¢…í•© í”„ë¡œì íŠ¸: ERP ì‹œìŠ¤í…œ êµ¬ì¶•

ERP(Enterprise Resource Planning) ì‹œìŠ¤í…œì€ ê¸°ì—…ì˜ ëª¨ë“  ìì›(ì¸ì‚¬, ì¬ë¬´, ìƒì‚°, í”„ë¡œì íŠ¸ ë“±)ì„ í†µí•©ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” MySQLì„ í™œìš©í•˜ì—¬ ê°„ë‹¨í•œ ERP ì‹œìŠ¤í…œì˜ í•µì‹¬ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆì™€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ êµ¬í˜„í•´ë´…ë‹ˆë‹¤.

### 4.1. ì™„ì „í•œ ERP ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„

ERP ì‹œìŠ¤í…œì€ ë‹¤ì–‘í•œ ëª¨ë“ˆ(ì¸ì‚¬, ì¬ë¬´, í”„ë¡œì íŠ¸ ë“±)ë¡œ êµ¬ì„±ë˜ë©°, ê° ëª¨ë“ˆì€ ì„œë¡œ ì—°ê´€ëœ í…Œì´ë¸”ë“¤ì„ ê°€ì§‘ë‹ˆë‹¤. í…Œì´ë¸” ê°„ì˜ ê´€ê³„(PRIMARY KEY, FOREIGN KEY)ë¥¼ ëª…í™•íˆ ì •ì˜í•˜ì—¬ ë°ì´í„°ì˜ ì¼ê´€ì„±ê³¼ ë¬´ê²°ì„±ì„ ë³´ì¥í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

#### í†µí•© ë¹„ì¦ˆë‹ˆìŠ¤ ì‹œìŠ¤í…œ êµ¬ì¶•
```sql
-- 1. íšŒì‚¬ ì¡°ì§ ê´€ë¦¬
CREATE TABLE companies (
    company_id INT PRIMARY KEY AUTO_INCREMENT,
    company_name VARCHAR(100) NOT NULL,
    business_number VARCHAR(20) UNIQUE,
    ceo_name VARCHAR(50),
    address TEXT,
    phone VARCHAR(20),
    email VARCHAR(100),
    established_date DATE,
    capital DECIMAL(15,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE departments (
    dept_id INT PRIMARY KEY AUTO_INCREMENT,
    company_id INT,
    dept_code VARCHAR(10) UNIQUE,
    dept_name VARCHAR(50) NOT NULL,
    parent_dept_id INT, -- ìƒìœ„ ë¶€ì„œ (ê³„ì¸µ êµ¬ì¡°)
    manager_id INT,
    location VARCHAR(100),
    budget DECIMAL(15,2),
    cost_center VARCHAR(20),
    established_date DATE,
    FOREIGN KEY (company_id) REFERENCES companies(company_id),
    FOREIGN KEY (parent_dept_id) REFERENCES departments(dept_id)
);

-- 2. ì¸ì‚¬ ê´€ë¦¬ ì‹œìŠ¤í…œ
CREATE TABLE positions (
    position_id INT PRIMARY KEY AUTO_INCREMENT,
    position_code VARCHAR(10) UNIQUE,
    position_name VARCHAR(50),
    level_order INT,
    min_salary DECIMAL(10,2),
    max_salary DECIMAL(10,2)
);

CREATE TABLE employees (
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    emp_number VARCHAR(20) UNIQUE,
    name VARCHAR(50) NOT NULL,
    english_name VARCHAR(100),
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20),
    dept_id INT,
    position_id INT,
    manager_id INT,
    hire_date DATE,
    employment_type ENUM('ì •ê·œì§', 'ê³„ì•½ì§', 'ì¸í„´', 'íŒŒê²¬'),
    status ENUM('ì¬ì§', 'íœ´ì§', 'í‡´ì§') DEFAULT 'ì¬ì§',
    salary DECIMAL(10,2),
    birth_date DATE,
    gender ENUM('M', 'F'),
    address TEXT,
    emergency_contact VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (dept_id) REFERENCES departments(dept_id),
    FOREIGN KEY (position_id) REFERENCES positions(position_id),
    FOREIGN KEY (manager_id) REFERENCES employees(emp_id) -- SELF JOIN ê´€ê³„
);

-- 3. í”„ë¡œì íŠ¸ ê´€ë¦¬ ì‹œìŠ¤í…œ
CREATE TABLE project_categories (
    category_id INT PRIMARY KEY AUTO_INCREMENT,
    category_name VARCHAR(50),
    description TEXT
);

CREATE TABLE projects (
    project_id INT PRIMARY KEY AUTO_INCREMENT,
    project_code VARCHAR(20) UNIQUE,
    project_name VARCHAR(100) NOT NULL,
    category_id INT,
    client_company VARCHAR(100),
    project_manager_id INT,
    start_date DATE,
    end_date DATE,
    status ENUM('ê¸°íš', 'ì§„í–‰ì¤‘', 'ì™„ë£Œ', 'ì¤‘ë‹¨', 'ë³´ë¥˜') DEFAULT 'ê¸°íš',
    budget DECIMAL(15,2),
    actual_cost DECIMAL(15,2) DEFAULT 0,
    description TEXT,
    priority ENUM('ë†’ìŒ', 'ë³´í†µ', 'ë‚®ìŒ') DEFAULT 'ë³´í†µ',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES project_categories(category_id),
    FOREIGN KEY (project_manager_id) REFERENCES employees(emp_id)
);

-- 4. ì¬ë¬´ ê´€ë¦¬ ì‹œìŠ¤í…œ
CREATE TABLE accounts (
    account_id INT PRIMARY KEY AUTO_INCREMENT,
    account_code VARCHAR(20) UNIQUE,
    account_name VARCHAR(100),
    account_type ENUM('ìì‚°', 'ë¶€ì±„', 'ìˆ˜ìµ', 'ë¹„ìš©', 'ìë³¸'), -- ìì‚°, ë¶€ì±„, ìë³¸, ìˆ˜ìµ, ë¹„ìš©
    parent_account_id INT, -- ê³„ì • ê³„ì¸µ êµ¬ì¡°
    is_active BOOLEAN DEFAULT TRUE,
    FOREIGN KEY (parent_account_id) REFERENCES accounts(account_id)
);

CREATE TABLE transactions (
    transaction_id INT PRIMARY KEY AUTO_INCREMENT,
    transaction_date DATE,
    description VARCHAR(200),
    reference_number VARCHAR(50),
    total_amount DECIMAL(15,2),
    created_by INT,
    approved_by INT,
    status ENUM('ì‘ì„±', 'ìŠ¹ì¸', 'ì™„ë£Œ') DEFAULT 'ì‘ì„±',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (created_by) REFERENCES employees(emp_id),
    FOREIGN KEY (approved_by) REFERENCES employees(emp_id)
);

CREATE TABLE transaction_details (
    detail_id INT PRIMARY KEY AUTO_INCREMENT,
    transaction_id INT,
    account_id INT,
    debit_amount DECIMAL(15,2) DEFAULT 0,
    credit_amount DECIMAL(15,2) DEFAULT 0,
    description VARCHAR(200),
    FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id),
    FOREIGN KEY (account_id) REFERENCES accounts(account_id)
);
```

### 4.2. ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ êµ¬í˜„

ERP ì‹œìŠ¤í…œì˜ í•µì‹¬ì€ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥ëœ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” ê¸‰ì—¬ ê³„ì‚°, í”„ë¡œì íŠ¸ ëŒ€ì‹œë³´ë“œ, ê²½ì˜ì§„ ë³´ê³ ì„œ ìƒì„±ê³¼ ê°™ì€ ì£¼ìš” ê¸°ëŠ¥ì„ ì €ì¥ í”„ë¡œì‹œì €ë¡œ êµ¬í˜„í•©ë‹ˆë‹¤.

#### ê¸‰ì—¬ ê³„ì‚° ì‹œìŠ¤í…œ

ì›”ë³„ ê¸‰ì—¬ë¥¼ ê³„ì‚°í•˜ê³  ëª…ì„¸ì„œë¥¼ ìƒì„±í•˜ëŠ” í”„ë¡œì‹œì €ì…ë‹ˆë‹¤. ì§ì› ì •ë³´, ì´ˆê³¼ ê·¼ë¬´, ì„±ê³¼ê¸‰ ë“±ì„ ê³ ë ¤í•˜ì—¬ ìµœì¢… ê¸‰ì—¬ë¥¼ ì‚°ì •í•©ë‹ˆë‹¤.

```sql
DELIMITER //

-- ì›”ê¸‰ì—¬ ê³„ì‚° í”„ë¡œì‹œì €
CREATE PROCEDURE CalculateMonthlyPayroll(
    IN payroll_year INT,
    IN payroll_month INT,
    IN dept_id_filter INT DEFAULT NULL -- íŠ¹ì • ë¶€ì„œë§Œ ê³„ì‚°í•  ê²½ìš° ì‚¬ìš©
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE emp_id INT;
    DECLARE base_salary DECIMAL(10,2);
    DECLARE overtime_hours DECIMAL(5,2);
    DECLARE bonus_amount DECIMAL(10,2);
    DECLARE deduction_amount DECIMAL(10,2);
    
    -- ê¸‰ì—¬ ê³„ì‚° ê²°ê³¼ ì„ì‹œ í…Œì´ë¸”
    DROP TEMPORARY TABLE IF EXISTS payroll_results;
    CREATE TEMPORARY TABLE payroll_results (
        emp_id INT,
        emp_name VARCHAR(50),
        dept_name VARCHAR(50),
        base_salary DECIMAL(10,2),
        overtime_pay DECIMAL(10,2),
        bonus DECIMAL(10,2),
        gross_pay DECIMAL(10,2),
        tax_deduction DECIMAL(10,2),
        insurance_deduction DECIMAL(10,2),
        total_deduction DECIMAL(10,2),
        net_pay DECIMAL(10,2)
    );
    
    -- ê¸‰ì—¬ ëŒ€ìƒì ì»¤ì„œ: ì¬ì§ ì¤‘ì¸ ì§ì›ë“¤ì„ ìˆœíšŒí•˜ë©° ê¸‰ì—¬ ê³„ì‚°
    DECLARE payroll_cursor CURSOR FOR
        SELECT e.emp_id, e.salary
        FROM employees e
        WHERE e.status = 'ì¬ì§'
          AND (dept_id_filter IS NULL OR e.dept_id = dept_id_filter);
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN payroll_cursor;
    
    payroll_loop: LOOP
        FETCH payroll_cursor INTO emp_id, base_salary;
        
        IF done THEN
            LEAVE payroll_loop;
        END IF;
        
        -- ì´ˆê³¼ê·¼ë¬´ ì‹œê°„ ì¡°íšŒ (ë³„ë„ í…Œì´ë¸”ì—ì„œ) - ì‹œë®¬ë ˆì´ì…˜ ë°ì´í„°
        SET overtime_hours = FLOOR(RAND() * 20);  
        
        -- ì„±ê³¼ê¸‰ ê³„ì‚° - ì‹œë®¬ë ˆì´ì…˜ ë¡œì§
        SET bonus_amount = CASE 
            WHEN base_salary >= 6000000 THEN base_salary * 0.1
            WHEN base_salary >= 4000000 THEN base_salary * 0.05
            ELSE 0
        END;
        
        -- ì„¸ê¸ˆ ë° ë³´í—˜ë£Œ ê³„ì‚° - ì‹œë®¬ë ˆì´ì…˜ ë¡œì§
        SET deduction_amount = base_salary * 0.15;  
        
        -- ê²°ê³¼ ì‚½ì…
        INSERT INTO payroll_results
        SELECT 
            e.emp_id,
            e.name,
            d.dept_name,
            base_salary,
            overtime_hours * (base_salary / 240),  -- ì‹œê°„ë‹¹ ê¸‰ì—¬ (ì›” 240ì‹œê°„ ê¸°ì¤€)
            bonus_amount,
            base_salary + (overtime_hours * (base_salary / 240)) + bonus_amount, -- ì´ ê¸‰ì—¬
            deduction_amount * 0.6,  -- ì„¸ê¸ˆ (ì´ ê³µì œì•¡ì˜ 60%)
            deduction_amount * 0.4,  -- ë³´í—˜ë£Œ (ì´ ê³µì œì•¡ì˜ 40%)
            deduction_amount, -- ì´ ê³µì œì•¡
            base_salary + (overtime_hours * (base_salary / 240)) + bonus_amount - deduction_amount -- ì‹¤ìˆ˜ë ¹ì•¡
        FROM employees e
        INNER JOIN departments d ON e.dept_id = d.dept_id
        WHERE e.emp_id = emp_id;
        
    END LOOP;
    
    CLOSE payroll_cursor;
    
    -- ê¸‰ì—¬ ëª…ì„¸ì„œ ì¶œë ¥
    SELECT * FROM payroll_results ORDER BY dept_name, emp_name;
    
    -- ë¶€ì„œë³„ ê¸‰ì—¬ ìš”ì•½
    SELECT 
        dept_name,
        COUNT(*) AS employee_count,
        SUM(base_salary) AS total_base_salary,
        SUM(overtime_pay) AS total_overtime_pay,
        SUM(bonus) AS total_bonus,
        SUM(gross_pay) AS total_gross_pay,
        SUM(total_deduction) AS total_deduction,
        SUM(net_pay) AS total_net_pay
    FROM payroll_results
    GROUP BY dept_name
    ORDER BY total_net_pay DESC;
    
END //

DELIMITER ;
```

#### ğŸ“Š í”„ë¡œì íŠ¸ ëŒ€ì‹œë³´ë“œ ì‹œìŠ¤í…œ

í”„ë¡œì íŠ¸ì˜ ì§„í–‰ í˜„í™©, ì˜ˆì‚° ì‚¬ìš©, ë¶€ì„œë³„ ì°¸ì—¬ë„ ë“±ì„ í•œëˆˆì— íŒŒì•…í•  ìˆ˜ ìˆëŠ” ëŒ€ì‹œë³´ë“œ ë°ì´í„°ë¥¼ ìƒì„±í•˜ëŠ” í”„ë¡œì‹œì €ì…ë‹ˆë‹¤.

```sql
DELIMITER //

-- í”„ë¡œì íŠ¸ ì¢…í•© ëŒ€ì‹œë³´ë“œ í”„ë¡œì‹œì €
CREATE PROCEDURE ProjectDashboard(
    IN start_date DATE,
    IN end_date DATE
)
BEGIN
    -- 1. í”„ë¡œì íŠ¸ í˜„í™© ìš”ì•½
    SELECT 
        'í”„ë¡œì íŠ¸ í˜„í™©' AS metric_category,
        status,
        COUNT(*) AS project_count,
        SUM(budget) AS total_budget,
        SUM(actual_cost) AS total_actual_cost,
        AVG(DATEDIFF(end_date, start_date)) AS avg_duration_days
    FROM projects
    WHERE start_date BETWEEN start_date AND end_date
    GROUP BY status;
    
    -- 2. ë¶€ì„œë³„ í”„ë¡œì íŠ¸ ì°¸ì—¬ë„
    SELECT 
        'ë¶€ì„œë³„ ì°¸ì—¬ë„' AS metric_category,
        d.dept_name AS status, -- status ì»¬ëŸ¼ì— ë¶€ì„œëª… ì‚¬ìš© (UNION ALL í˜¸í™˜ì„ ìœ„í•´)
        COUNT(DISTINCT p.project_id) AS project_count,
        SUM(p.budget) AS total_budget,
        0 AS total_actual_cost, -- UNION ALL í˜¸í™˜ì„ ìœ„í•´ 0ìœ¼ë¡œ ì±„ì›€
        0 AS avg_duration_days -- UNION ALL í˜¸í™˜ì„ ìœ„í•´ 0ìœ¼ë¡œ ì±„ì›€
    FROM projects p
    INNER JOIN project_assignments pa ON p.project_id = pa.project_id
    INNER JOIN employees e ON pa.emp_id = e.emp_id
    INNER JOIN departments d ON e.dept_id = d.dept_id
    WHERE p.start_date BETWEEN start_date AND end_date
    GROUP BY d.dept_id, d.dept_name
    ORDER BY metric_category, total_budget DESC;
    
    -- 3. ìˆ˜ìµì„± ë¶„ì„
    WITH project_profitability AS (
        SELECT 
            p.project_name,
            p.budget,
            p.actual_cost,
            p.budget - p.actual_cost AS profit,
            ROUND((p.budget - p.actual_cost) / p.budget * 100, 2) AS profit_margin,
            CASE 
                WHEN p.actual_cost > p.budget * 1.1 THEN 'Over Budget'
                WHEN p.actual_cost > p.budget * 0.9 THEN 'On Budget'
                ELSE 'Under Budget'
            END AS budget_status
        FROM projects p
        WHERE p.status = 'ì™„ë£Œ'
          AND p.start_date BETWEEN start_date AND end_date
    )
    SELECT 
        budget_status,
        COUNT(*) AS project_count,
        AVG(profit_margin) AS avg_profit_margin,
        SUM(profit) AS total_profit
    FROM project_profitability
    GROUP BY budget_status;
END //

DELIMITER ;

-- ëŒ€ì‹œë³´ë“œ ì‹¤í–‰
CALL ProjectDashboard('2024-01-01', '2024-12-31');
```

### 4.3. ë³´ê³ ì„œ ìë™í™” ì‹œìŠ¤í…œ

ì›”ê°„ ê²½ì˜ ë³´ê³ ì„œì™€ ê°™ì´ ì •ê¸°ì ìœ¼ë¡œ í•„ìš”í•œ ë°ì´í„°ë¥¼ ìë™ìœ¼ë¡œ ì§‘ê³„í•˜ê³  í¬ë§·íŒ…í•˜ì—¬ ê²½ì˜ì§„ì—ê²Œ ì œê³µí•˜ëŠ” í”„ë¡œì‹œì €ì…ë‹ˆë‹¤.

```sql
DELIMITER //

-- ì›”ê°„ ê²½ì˜ ë³´ê³ ì„œ ìƒì„± í”„ë¡œì‹œì €
CREATE PROCEDURE GenerateExecutiveReport(
    IN report_year INT,
    IN report_month INT
)
BEGIN
    DECLARE report_start_date DATE;
    DECLARE report_end_date DATE;
    
    SET report_start_date = STR_TO_DATE(CONCAT(report_year, '-', report_month, '-01'), '%Y-%m-%d');
    SET report_end_date = LAST_DAY(report_start_date); -- í•´ë‹¹ ì›”ì˜ ë§ˆì§€ë§‰ ë‚ ì§œ ê³„ì‚°
    
    -- ë³´ê³ ì„œ í—¤ë”
    SELECT 
        CONCAT(report_year, 'ë…„ ', report_month, 'ì›” ê²½ì˜ ë³´ê³ ì„œ') AS report_title,
        NOW() AS generated_at;
    
    -- 1. ì¸ë ¥ í˜„í™©
    SELECT 
        'ì¸ë ¥ í˜„í™©' AS section,
        d.dept_name AS department,
        COUNT(e.emp_id) AS headcount,
        SUM(e.salary) AS total_salary_cost,
        AVG(e.salary) AS avg_salary,
        COUNT(CASE WHEN e.hire_date >= report_start_date THEN 1 END) AS new_hires,
        COUNT(CASE WHEN e.status = 'í‡´ì§' THEN 1 END) AS departures
    FROM departments d
    LEFT JOIN employees e ON d.dept_id = e.dept_id
    GROUP BY d.dept_id, d.dept_name
    ORDER BY total_salary_cost DESC;
    
    -- 2. í”„ë¡œì íŠ¸ ì„±ê³¼
    SELECT 
        'í”„ë¡œì íŠ¸ ì„±ê³¼' AS section,
        p.status,
        COUNT(*) AS project_count,
        SUM(p.budget) AS total_budget,
        SUM(p.actual_cost) AS total_cost,
        SUM(p.budget - p.actual_cost) AS total_profit,
        ROUND(AVG((p.budget - p.actual_cost) / p.budget * 100), 2) AS avg_profit_margin
    FROM projects p
    WHERE p.start_date <= report_end_date
      AND (p.end_date >= report_start_date OR p.end_date IS NULL) -- í˜„ì¬ ì§„í–‰ ì¤‘ì´ê±°ë‚˜ ì™„ë£Œëœ í”„ë¡œì íŠ¸
    GROUP BY p.status;
    
    -- 3. ì¬ë¬´ í˜„í™© (ê°„ë‹¨ ë²„ì „)
    SELECT 
        'ì¬ë¬´ í˜„í™©' AS section,
        a.account_type,
        SUM(CASE WHEN td.debit_amount > 0 THEN td.debit_amount ELSE 0 END) AS total_debit,
        SUM(CASE WHEN td.credit_amount > 0 THEN td.credit_amount ELSE 0 END) AS total_credit,
        SUM(td.debit_amount - td.credit_amount) AS net_balance
    FROM accounts a
    LEFT JOIN transaction_details td ON a.account_id = td.account_id
    LEFT JOIN transactions t ON td.transaction_id = t.transaction_id
    WHERE t.transaction_date BETWEEN report_start_date AND report_end_date
    GROUP BY a.account_type;
    
    -- 4. í•µì‹¬ ì„±ê³¼ ì§€í‘œ (KPI)
    SELECT 
        'KPI' AS section,
        'Employee Productivity' AS kpi_name,
        ROUND(
            (SELECT SUM(budget) FROM projects WHERE status = 'ì™„ë£Œ' 
             AND end_date BETWEEN report_start_date AND report_end_date) / -- ì™„ë£Œëœ í”„ë¡œì íŠ¸ ì˜ˆì‚° í•©ê³„
            (SELECT COUNT(*) FROM employees WHERE status = 'ì¬ì§'), 0 -- ì¬ì§ ì¤‘ì¸ ì§ì› ìˆ˜
        ) AS kpi_value,
        'ì›/ì¸' AS unit;
        
END //

DELIMITER ;

-- ë³´ê³ ì„œ ìƒì„± ì‹¤í–‰
CALL GenerateExecutiveReport(2024, 5);
```

---

## 5. ë°±ì—…ê³¼ ë³µì› ì „ëµ: ë°ì´í„° ì•ˆì •ì„± í™•ë³´
ë°ì´í„°ë² ì´ìŠ¤ ìš´ì˜ì—ì„œ ë°±ì—…ê³¼ ë³µì›ì€ ë‹¨ìˆœí•œ ê¸°ìˆ ì  ì‘ì—…ì„ ë„˜ì–´, ì„œë¹„ìŠ¤ ì¤‘ë‹¨ ì—†ì´ ë¹„ì¦ˆë‹ˆìŠ¤ ì—°ì†ì„±ì„ ìœ ì§€í•˜ëŠ” í•µì‹¬ ì „ëµì…ë‹ˆë‹¤. ì˜ˆê¸°ì¹˜ ëª»í•œ ì¥ì• ë‚˜ ìì—°ì¬í•´, ì‚¬ìš©ì ì‹¤ìˆ˜ë¡œë¶€í„° ë°ì´í„°ë¥¼ ë³´í˜¸í•˜ê³  ë¹ ë¥´ê²Œ ë³µêµ¬í•  ìˆ˜ ìˆëŠ” ì²´ê³„ì ì¸ ì ‘ê·¼ì´ í•„ìš”í•©ë‹ˆë‹¤.
### 5.1 ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ì „ëµ
ë°±ì—… ì „ëµì€ ë°ì´í„°ë¥¼ ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ, ì–¼ë§ˆë‚˜ ìì£¼, ì–´ë–¤ í˜•íƒœë¡œ ì €ì¥í•  ê²ƒì¸ì§€ ê²°ì •í•˜ëŠ” ê³¼ì •ì…ë‹ˆë‹¤. ë°ì´í„°ì˜ ì¤‘ìš”ë„ì™€ ì‹œìŠ¤í…œ ìš´ì˜ í™˜ê²½ì— ë”°ë¼ ì „ì²´ ë°±ì—…, ì¦ë¶„ ë°±ì—…, ì°¨ë“± ë°±ì—…ì„ ì ì ˆíˆ ì¡°í•©í•©ë‹ˆë‹¤.
#### ìë™í™”ëœ ë°±ì—… ì‹œìŠ¤í…œ
ìë™í™”ëœ ë°±ì—… ì‹œìŠ¤í…œì€ ìš´ì˜ìì˜ ì‹¤ìˆ˜ë¥¼ ì¤„ì´ê³ , ì¼ì •í•œ ê°„ê²©ìœ¼ë¡œ ë°±ì—…ì„ ìˆ˜í–‰í•˜ë©°, ê·¸ ê²°ê³¼ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤. ì•„ë˜ ì˜ˆì‹œëŠ” MySQL í™˜ê²½ì—ì„œ ë°±ì—… ë¡œê·¸ 

í…Œì´ë¸”ê³¼ ë°±ì—… ì‹¤í–‰ í”„ë¡œì‹œì €ë¥¼ ì´ìš©í•˜ì—¬ ë°±ì—… í”„ë¡œì„¸ìŠ¤ë¥¼ ê´€ë¦¬í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤:
- ë°±ì—… ë¡œê·¸ì—ëŠ” ì‹¤í–‰ ì‹œê°„, ë°±ì—… ì¢…ë¥˜, ë°±ì—… ìš©ëŸ‰, ì„±ê³µ/ì‹¤íŒ¨ ì—¬ë¶€, ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ë‚¨ê¹ë‹ˆë‹¤.
- ExecuteBackup í”„ë¡œì‹œì €ëŠ” ë°±ì—… ëª…ë ¹ì–´ ìƒì„±, ë¡œê·¸ ê¸°ë¡, ì‹œë®¬ë ˆì´ì…˜ ê¸°ë°˜ ê²°ê³¼ ì²˜ë¦¬ë¥¼ ìë™ìœ¼ë¡œ ìˆ˜í–‰í•©ë‹ˆë‹¤.
- ë°±ì—… ì´ë ¥ì€ backup_log í…Œì´ë¸”ì„ í†µí•´ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì‹¤ì œ ë°±ì—…ì€ ìš´ì˜ ì‹œìŠ¤í…œ ë˜ëŠ” ì™¸ë¶€ ìŠ¤í¬ë¦½íŠ¸ë¡œ ì‹¤í–‰í•´ì•¼ í•˜ë©°, ë°±ì—… íŒŒì¼ì˜ ìœ„ì¹˜ì™€ í¬ê¸°ë„ ê´€ë¦¬ ëŒ€ìƒì…ë‹ˆë‹¤.
```sql
-- ë°±ì—… ë¡œê·¸ í…Œì´ë¸”
CREATE TABLE backup_log (
    backup_id INT PRIMARY KEY AUTO_INCREMENT,
    backup_type ENUM('FULL', 'INCREMENTAL', 'DIFFERENTIAL'),
    backup_file_path VARCHAR(500),
    backup_size_mb DECIMAL(10,2),
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    status ENUM('SUCCESS', 'FAILED', 'IN_PROGRESS'),
    error_message TEXT,
    created_by VARCHAR(50) DEFAULT USER()
);

-- ë°±ì—… ì‹¤í–‰ í”„ë¡œì‹œì €
DELIMITER //
CREATE PROCEDURE ExecuteBackup(
    IN backup_type_param VARCHAR(20),
    IN backup_path VARCHAR(500)
)
BEGIN
    DECLARE backup_start TIMESTAMP DEFAULT NOW();
    DECLARE backup_id INT;
    DECLARE backup_command TEXT;
    
    -- ë°±ì—… ë¡œê·¸ ì‹œì‘ ê¸°ë¡
    INSERT INTO backup_log (backup_type, backup_file_path, start_time, status)
    VALUES (backup_type_param, backup_path, backup_start, 'IN_PROGRESS');
    
    SET backup_id = LAST_INSERT_ID();
    
    -- ë°±ì—… ëª…ë ¹ì–´ ìƒì„± (ì‹¤ì œ ì‹¤í–‰ì€ ì‹œìŠ¤í…œ ë ˆë²¨ì—ì„œ)
    SET backup_command = CONCAT(
        'mysqldump -u root -p --routines --triggers --single-transaction ',
        DATABASE(), ' > ', backup_path
    );
    
    -- ë°±ì—… ì™„ë£Œ ê¸°ë¡ (ì‹œë®¬ë ˆì´ì…˜)
    UPDATE backup_log 
    SET end_time = NOW(), 
        status = 'SUCCESS',
        backup_size_mb = ROUND(RAND() * 1000 + 100, 2)  -- ì‹œë®¬ë ˆì´ì…˜
    WHERE backup_log.backup_id = backup_id;
    
    -- ë°±ì—… ëª…ë ¹ì–´ ì¶œë ¥
    SELECT backup_command AS 'Execute this command in terminal:';
    
END //
DELIMITER ;

-- ë°±ì—… ì‹¤í–‰
CALL ExecuteBackup('FULL', '/backup/daily_backup_2024_05_26.sql');

-- ë°±ì—… ì´ë ¥ ì¡°íšŒ
SELECT 
    backup_type,
    backup_file_path,
    backup_size_mb,
    TIMESTAMPDIFF(MINUTE, start_time, end_time) AS duration_minutes,
    status,
    start_time
FROM backup_log
ORDER BY start_time DESC;
```

### 5.2 ì¬í•´ ë³µêµ¬ ê³„íš
ì¬í•´ ë³µêµ¬(DR, Disaster Recovery)ëŠ” ì‹œìŠ¤í…œ ì¥ì•  ë°œìƒ ì‹œ ì–¼ë§ˆë‚˜ ë¹ ë¥´ê²Œ ì •ìƒ ìƒíƒœë¡œ ëŒì•„ê°ˆ ìˆ˜ ìˆëŠ”ì§€ë¥¼ ì •ì˜í•©ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ ë³µêµ¬ ìš°ì„ ìˆœìœ„ ì„¤ì •ê³¼ ë°±ì—… ì£¼ê¸° ê´€ë¦¬ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤.

#### ë¹„ì¦ˆë‹ˆìŠ¤ ì—°ì†ì„± ê³„íš
ë³µêµ¬ ìš°ì„ ìˆœìœ„ë¥¼ ì •ì˜í•¨ìœ¼ë¡œì¨, ì–´ë–¤ í…Œì´ë¸”ì„ ê°€ì¥ ë¨¼ì € ë³µêµ¬í•  ê²ƒì¸ì§€, ì–¼ë§ˆë‚˜ ìì£¼ ë°±ì—…í•  ê²ƒì¸ì§€ë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤:
- í•µì‹¬ í…Œì´ë¸”(ex: employees, departments)ì€ CRITICALë¡œ ì§€ì •í•˜ê³ , 1ì‹œê°„ ë‚´ ë³µêµ¬ ëª©í‘œ(RTO)ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
- ë°±ì—… ì£¼ê¸°ëŠ” ì¤‘ìš”ë„ì— ë”°ë¼ ì°¨ë“± ì ìš©ë˜ë©°, ì´ë¥¼ í…Œì´ë¸”ì— êµ¬ì¡°ì ìœ¼ë¡œ ëª…ì‹œí•©ë‹ˆë‹¤.
- ìš°ì„ ìˆœìœ„ í…Œì´ë¸”ì—ì„œ ê·¸ë£¹ë³„ ë³µêµ¬ ëª©í‘œ ì‹œê°„(RTO) ë° ìµœì†Œ ë°±ì—… ë¹ˆë„ë¥¼ ì¡°íšŒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ëŸ° êµ¬ì¡°ëŠ” ì‹œìŠ¤í…œì˜ ë³µì¡ì„±ì´ ë†’ì•„ì§ˆìˆ˜ë¡ ë”ìš± ìœ ìš©í•˜ë©°, ì‹¤ì œ ë³µêµ¬ ì‹œì—ë„ ì˜ì‚¬ê²°ì •ì— ê¸°ì¤€ì´ ë©ë‹ˆë‹¤.
```sql
-- ì¤‘ìš” í…Œì´ë¸” ìš°ì„ ìˆœìœ„ ì •ì˜
CREATE TABLE recovery_priorities (
    table_name VARCHAR(100) PRIMARY KEY,
    priority_level ENUM('CRITICAL', 'HIGH', 'MEDIUM', 'LOW'),
    recovery_time_objective_hours INT,  -- ë³µêµ¬ ëª©í‘œ ì‹œê°„
    backup_frequency_hours INT,         -- ë°±ì—… ì£¼ê¸°
    description TEXT
);

-- ë³µêµ¬ ìš°ì„ ìˆœìœ„ ë°ì´í„°
INSERT INTO recovery_priorities VALUES
('companies', 'CRITICAL', 1, 6, 'íšŒì‚¬ ê¸°ë³¸ ì •ë³´'),
('employees', 'CRITICAL', 1, 6, 'ì§ì› ì •ë³´'),
('projects', 'HIGH', 4, 12, 'í”„ë¡œì íŠ¸ ì •ë³´'),
('transactions', 'HIGH', 4, 12, 'ì¬ë¬´ ê±°ë˜'),
('departments', 'CRITICAL', 1, 6, 'ì¡°ì§ êµ¬ì¡°'),
('accounts', 'HIGH', 2, 8, 'ê³„ì • ì •ë³´'),
('salary_history', 'MEDIUM', 8, 24, 'ê¸‰ì—¬ ì´ë ¥'),
('project_assignments', 'MEDIUM', 8, 24, 'í”„ë¡œì íŠ¸ ë°°ì •'),
('backup_log', 'LOW', 24, 48, 'ë°±ì—… ë¡œê·¸');

-- ë³µêµ¬ ê³„íš ì¡°íšŒ
SELECT 
    priority_level,
    COUNT(*) AS table_count,
    MAX(recovery_time_objective_hours) AS max_rto_hours,
    MIN(backup_frequency_hours) AS min_backup_freq
FROM recovery_priorities
GROUP BY priority_level
ORDER BY FIELD(priority_level, 'CRITICAL', 'HIGH', 'MEDIUM', 'LOW');
```

---

## 6. ìµœì¢… ì„±ê³¼ í‰ê°€: í•™ìŠµ ê²°ê³¼ ê²€ì¦

### 6.1 ì‹œìŠ¤í…œ ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí¬

#### ì¢…í•© ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
```sql
-- ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ê²°ê³¼ í…Œì´ë¸”
CREATE TABLE performance_benchmark (
    test_id INT PRIMARY KEY AUTO_INCREMENT,
    test_name VARCHAR(100),
    query_type VARCHAR(50),
    execution_time_ms DECIMAL(10,3),
    rows_examined INT,
    rows_returned INT,
    index_usage VARCHAR(200),
    optimization_notes TEXT,
    test_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ë³µì¡í•œ ë¶„ì„ ì¿¼ë¦¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
DELIMITER //
CREATE PROCEDURE BenchmarkComplexQueries()
BEGIN
    DECLARE start_time DECIMAL(15,6);
    DECLARE end_time DECIMAL(15,6);
    DECLARE execution_time DECIMAL(10,3);
    
    -- 1. ë‹¤ì¤‘ JOIN ì¿¼ë¦¬ í…ŒìŠ¤íŠ¸
    SET start_time = UNIX_TIMESTAMP(NOW(6));
    
    SELECT COUNT(*) FROM (
        SELECT 
            e.name,
            d.dept_name,
            p.project_name,
            SUM(pa.allocation_percent) as total_allocation
        FROM employees e
        INNER JOIN departments d ON e.dept_id = d.dept_id
        INNER JOIN project_assignments pa ON e.emp_id = pa.emp_id
        INNER JOIN projects p ON pa.project_id = p.project_id
        WHERE e.salary > 4000000
        GROUP BY e.emp_id, e.name, d.dept_name, p.project_name
        HAVING total_allocation > 50
    ) AS complex_query;
    
    SET end_time = UNIX_TIMESTAMP(NOW(6));
    SET execution_time = (end_time - start_time) * 1000;
    
    INSERT INTO performance_benchmark 
    (test_name, query_type, execution_time_ms, optimization_notes)
    VALUES ('Complex Multi-JOIN', 'ANALYTICAL', execution_time, 'Multi-table join with aggregation');
    
    -- 2. ì„œë¸Œì¿¼ë¦¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
    SET start_time = UNIX_TIMESTAMP(NOW(6));
    
    SELECT COUNT(*) FROM employees e
    WHERE e.salary > (
        SELECT AVG(salary) FROM employees 
        WHERE department = e.department
    ) AND EXISTS (
        SELECT 1 FROM project_assignments pa 
        WHERE pa.emp_id = e.emp_id
    );
    
    SET end_time = UNIX_TIMESTAMP(NOW(6));
    SET execution_time = (end_time - start_time) * 1000;
    
    INSERT INTO performance_benchmark 
    (test_name, query_type, execution_time_ms, optimization_notes)
    VALUES ('Correlated Subquery with EXISTS', 'SUBQUERY', execution_time, 'Correlated subquery performance');
    
    -- 3. ìœˆë„ìš° í•¨ìˆ˜ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
    SET start_time = UNIX_TIMESTAMP(NOW(6));
    
    SELECT COUNT(*) FROM (
        SELECT 
            name,
            salary,
            RANK() OVER (PARTITION BY department ORDER BY salary DESC) as dept_rank,
            LAG(salary) OVER (PARTITION BY department ORDER BY hire_date) as prev_salary
        FROM employees
        WHERE salary IS NOT NULL
    ) ranked_employees;
    
    SET end_time = UNIX_TIMESTAMP(NOW(6));
    SET execution_time = (end_time - start_time) * 1000;
    
    INSERT INTO performance_benchmark 
    (test_name, query_type, execution_time_ms, optimization_notes)
    VALUES ('Window Functions', 'ANALYTICAL', execution_time, 'RANK and LAG window functions');
    
END //
DELIMITER ;

-- ë²¤ì¹˜ë§ˆí¬ ì‹¤í–‰
CALL BenchmarkComplexQueries();

-- ì„±ëŠ¥ ê²°ê³¼ ë¶„ì„
SELECT 
    query_type,
    COUNT(*) as test_count,
    AVG(execution_time_ms) as avg_execution_time,
    MAX(execution_time_ms) as max_execution_time,
    MIN(execution_time_ms) as min_execution_time
FROM performance_benchmark
GROUP BY query_type
ORDER BY avg_execution_time DESC;
```

### 6.2 í•™ìŠµ ì„±ê³¼ ì²´í¬ë¦¬ìŠ¤íŠ¸

#### ìµœì¢… ì—­ëŸ‰ í‰ê°€
```sql
-- í•™ìŠµ ì„±ê³¼ í‰ê°€ í…Œì´ë¸”
CREATE TABLE learning_assessment (
    skill_category VARCHAR(50),
    skill_name VARCHAR(100),
    proficiency_level ENUM('ì´ˆê¸‰', 'ì¤‘ê¸‰', 'ê³ ê¸‰', 'ì „ë¬¸ê°€'),
    practical_examples TEXT,
    mastery_score INT CHECK (mastery_score BETWEEN 0 AND 100)
);

-- í•™ìŠµ ì„±ê³¼ ë°ì´í„° ì…ë ¥
INSERT INTO learning_assessment VALUES
('ê¸°ë³¸ SQL', 'SELECT, INSERT, UPDATE, DELETE', 'ì „ë¬¸ê°€', 'CRUD ì—°ì‚° ì™„ë²½ êµ¬ì‚¬', 95),
('ì¡°ì¸', 'INNER, LEFT, RIGHT, SELF JOIN', 'ì „ë¬¸ê°€', 'ë³µì¡í•œ ë‹¤ì¤‘ í…Œì´ë¸” ì¡°ì¸ êµ¬í˜„', 90),
('ì„œë¸Œì¿¼ë¦¬', 'ìƒê´€ ì„œë¸Œì¿¼ë¦¬, EXISTS, CTE', 'ê³ ê¸‰', 'ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ êµ¬í˜„', 85),
('ì§‘ê³„ í•¨ìˆ˜', 'GROUP BY, HAVING, ìœˆë„ìš° í•¨ìˆ˜', 'ê³ ê¸‰', 'ê³ ê¸‰ ë¶„ì„ ì¿¼ë¦¬ ì‘ì„±', 85),
('ì„±ëŠ¥ ìµœì í™”', 'ì¸ë±ìŠ¤, ì‹¤í–‰ ê³„íš, íŠœë‹', 'ì¤‘ê¸‰', 'ê¸°ë³¸ì ì¸ ì„±ëŠ¥ ìµœì í™”', 75),
('í•¨ìˆ˜/í”„ë¡œì‹œì €', 'ì‚¬ìš©ì ì •ì˜ í•¨ìˆ˜, ì €ì¥ í”„ë¡œì‹œì €', 'ê³ ê¸‰', 'ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ëª¨ë“ˆí™”', 80),
('íŠ¸ëœì­ì…˜', 'ACID, ê²©ë¦¬ ìˆ˜ì¤€, ë™ì‹œì„± ì œì–´', 'ì¤‘ê¸‰', 'ì•ˆì „í•œ íŠ¸ëœì­ì…˜ ì²˜ë¦¬', 75),
('ì‹¤ë¬´ ì‘ìš©', 'ERP ì‹œìŠ¤í…œ, ë³´ê³ ì„œ ìë™í™”', 'ê³ ê¸‰', 'ì¢…í•©ì ì¸ ì‹œìŠ¤í…œ êµ¬ì¶•', 85);

-- ìµœì¢… ì„±ê³¼ ë¦¬í¬íŠ¸
SELECT 
    skill_category,
    COUNT(*) as skill_count,
    AVG(mastery_score) as avg_mastery_score,
    GROUP_CONCAT(
        CONCAT(skill_name, '(', proficiency_level, ')')
        ORDER BY mastery_score DESC
    ) as skills_summary
FROM learning_assessment
GROUP BY skill_category
ORDER BY avg_mastery_score DESC;

-- ì „ì²´ í•™ìŠµ ì„±ê³¼ ìš”ì•½
SELECT 
    ROUND(AVG(mastery_score), 1) as overall_mastery_score,
    COUNT(CASE WHEN proficiency_level = 'ì „ë¬¸ê°€' THEN 1 END) as expert_skills,
    COUNT(CASE WHEN proficiency_level = 'ê³ ê¸‰' THEN 1 END) as advanced_skills,
    COUNT(CASE WHEN proficiency_level = 'ì¤‘ê¸‰' THEN 1 END) as intermediate_skills,
    COUNT(*) as total_skills,
    CASE 
        WHEN AVG(mastery_score) >= 90 THEN 'SQL ì „ë¬¸ê°€ ìˆ˜ì¤€'
        WHEN AVG(mastery_score) >= 80 THEN 'SQL ê³ ê¸‰ ê°œë°œì ìˆ˜ì¤€'
        WHEN AVG(mastery_score) >= 70 THEN 'SQL ì¤‘ê¸‰ ê°œë°œì ìˆ˜ì¤€'
        ELSE 'SQL ì´ˆê¸‰ ê°œë°œì ìˆ˜ì¤€'
    END as certification_level
FROM learning_assessment;
```
---

## 7. ë§ˆë¬´ë¦¬: í•µì‹¬ ì •ë¦¬

### ì‹¤ë¬´ ì ìš© ê°€ì´ë“œ

#### ì¦‰ì‹œ ì ìš© ê°€ëŠ¥í•œ ê¸°ìˆ 
1. **íŠ¸ëœì­ì…˜ ì„¤ê³„**: ê¸ˆìœµ, ì „ììƒê±°ë˜ ì‹œìŠ¤í…œ
2. **ì„±ëŠ¥ ìµœì í™”**: ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì‹œìŠ¤í…œ
3. **ë³µí•© ì¿¼ë¦¬**: ë¹„ì¦ˆë‹ˆìŠ¤ ì¸í…”ë¦¬ì „ìŠ¤, ë¶„ì„ ì‹œìŠ¤í…œ
4. **ìë™í™” í”„ë¡œì‹œì €**: ì •ê¸° ë³´ê³ ì„œ, ë°°ì¹˜ ì²˜ë¦¬
---
[â®ï¸ ì´ì „ ë¬¸ì„œ](./0520_SQLì •ë¦¬.md) | [ë‹¤ìŒ ë¬¸ì„œ â­ï¸](./0527_SQLAlchemyì •ë¦¬.md)