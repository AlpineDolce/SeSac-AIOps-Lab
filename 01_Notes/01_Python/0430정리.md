# 🐍 Python 심화: 자료 구조 활용과 검색/정렬 알고리즘 (Day 6)

> **이 문서의 목적**: 이 문서는 부트캠프 6일차에 학습한 Python의 내장 함수 `zip`과 `dict`의 실용적인 활용법, 그리고 컴퓨터 과학의 근간이 되는 **검색(Search)** 및 **정렬(Sort)** 알고리즘의 기초를 깊이 있게 정리한 자료입니다. 각 알고리즘의 동작 원리, 시간 복잡도, 그리고 장단점을 명확히 비교하여 문제 해결 능력을 보여주는 것을 목표로 합니다.

---

## 목차

1.  [**데이터 구조화의 달인: `zip`과 `dict` 활용**](#1-데이터-구조화의-달인-zip과-dict-활용)
    -   [`zip()`: 여러 데이터를 병렬로 묶기](#zip-여러-데이터를-병렬로-묶기)
    -   [`dict()`: 키-값 쌍으로 데이터 구성하기](#dict-키-값-쌍으로-데이터-구성하기)
2.  [**검색(Search) 알고리즘: 원하는 데이터를 찾아라**](#2-검색search-알고리즘-원하는-데이터를-찾아라)
    -   [순차 검색 (Sequential Search)](#순차-검색-sequential-search)
    -   [이진 검색 (Binary Search)](#이진-검색-binary-search)
    -   [해시 검색 (Hash Search)](#해시-검색-hash-search)
    -   [검색 알고리즘 비교 요약](#검색-알고리즘-비교-요약)
3.  [**정렬(Sort) 알고리즘: 데이터를 가지런히**](#3-정렬sort-알고리즘-데이터를-가지런히)
    -   [선택 정렬 (Selection Sort)](#선택-정렬-selection-sort)
    -   [정렬 알고리즘의 종류와 특징](#정렬-알고리즘의-종류와-특징)

---

## 1. 데이터 구조화의 달인: `zip`과 `dict` 활용

### `zip()`: 여러 데이터를 병렬로 묶기

`zip()` 함수는 여러 개의 **반복 가능한 객체(iterable)**의 원소들을 순서대로 묶어 **튜플(tuple)**의 연속으로 만들어주는 강력한 도구입니다.

-   **반환값**: `zip` 객체. 이는 **이터레이터(iterator)**이므로, 한 번 순회하면 내용이 소진됩니다. 결과를 여러 번 사용하려면 `list()`나 `tuple()`로 변환하여 저장해야 합니다.
-   **길이 주의**: 묶이는 객체들의 길이가 다를 경우, **가장 짧은 길이를 기준**으로 묶이며 나머지 원소들은 버려집니다.

```python
# 기본 사용법
names = ['Alice', 'Bob', 'Charlie']
scores = [85, 92, 78]
ages = (25, 30, 28) # 다른 타입의 iterable도 가능

# 여러 리스트를 병렬로 묶기
student_profiles = list(zip(names, scores, ages))
print(student_profiles)
# 출력: [('Alice', 85, 25), ('Bob', 92, 30), ('Charlie', 78, 28)]

# 언패킹(Unzip): 묶인 데이터를 다시 분리하기
unzipped_names, unzipped_scores, unzipped_ages = zip(*student_profiles)
print(f"Names: {unzipped_names}") # ('Alice', 'Bob', 'Charlie')
```

### `dict()`: 키-값 쌍으로 데이터 구성하기

`dict()` 생성자는 다양한 형태의 입력을 받아 딕셔너리를 만듭니다. 특히 `zip()`과 함께 사용하면 두 개의 리스트(하나는 키, 하나는 값)를 손쉽게 딕셔너리로 변환할 수 있습니다.

```python
# 키 리스트와 값 리스트 준비
keys = ['name', 'age', 'city']
values = ['David', 35, 'New York']

# zip과 dict를 함께 사용하여 딕셔너리 생성
person_dict = dict(zip(keys, values))
print(person_dict)
# 출력: {'name': 'David', 'age': 35, 'city': 'New York'}

# 키워드 인자를 사용한 생성
person_dict_kw = dict(name="Eve", age=22)
print(person_dict_kw) # {'name': 'Eve', 'age': 22}
```

> **💡 실무 Tip**: CSV 파일이나 데이터베이스에서 가져온 데이터를 각 열의 이름(header)을 키로, 각 행의 데이터를 값으로 매핑하여 딕셔너리 리스트를 만들 때 `zip`과 `dict`의 조합이 매우 유용하게 사용됩니다.

---

## 2. 검색(Search) 알고리즘: 원하는 데이터를 찾아라

### 순차 검색 (Sequential Search)

-   **개념**: 데이터의 첫 번째 원소부터 마지막 원소까지 **하나씩 순서대로** 원하는 값을 찾아나가는 가장 간단한 검색 방식입니다.
-   **장점**: 구현이 매우 쉽고, 데이터가 정렬되어 있지 않아도 사용할 수 있습니다.
-   **단점**: 데이터의 양이 많아질수록 검색 시간이 정비례하여 증가합니다. (비효율적)
-   **시간 복잡도**: O(n) - 최악의 경우 모든 데이터를 확인해야 합니다.

```python
def sequential_search(data_list, target):
    """리스트에서 target 값의 인덱스를 찾아 반환합니다. 없으면 -1을 반환합니다."""
    for i in range(len(data_list)):
        if data_list[i] == target:
            return i  # 값을 찾으면 해당 인덱스 반환
    return -1 # 끝까지 찾아도 없으면 -1 반환
```

### 이진 검색 (Binary Search)

-   **개념**: **반드시 정렬된 데이터**에서 사용 가능한 고효율 검색 알고리즘입니다. 검색 범위를 계속해서 절반으로 줄여나가며 값을 찾습니다.
-   **동작 방식**:
    1.  데이터의 중간(mid) 원소를 선택합니다.
    2.  찾는 값(target)과 중간 값을 비교합니다.
    3.  `target > mid`이면 오른쪽 절반을, `target < mid`이면 왼쪽 절반을 대상으로 검색을 반복합니다.
-   **장점**: 데이터 양이 아무리 많아져도 검색 시간이 매우 느리게 증가하여 대용량 데이터 처리에 적합합니다.
-   **시간 복잡도**: O(log n)

```python
def binary_search(sorted_list, target):
    """정렬된 리스트에서 target 값의 인덱스를 찾아 반환합니다."""
    low = 0
    high = len(sorted_list) - 1

    while low <= high:
        mid = (low + high) // 2
        if sorted_list[mid] == target:
            return mid
        elif sorted_list[mid] < target:
            low = mid + 1 # 중간값보다 크면, 탐색 범위를 오른쪽으로 좁힘
        else:
            high = mid - 1 # 중간값보다 작으면, 탐색 범위를 왼쪽으로 좁힘
    return -1
```

### 해시 검색 (Hash Search)

-   **개념**: 해시 함수(Hash Function)를 사용하여 각 데이터를 고유한 숫자(해시 값)로 변환하고, 이 해시 값을 인덱스로 사용하여 데이터를 해시 테이블(Hash Table)에 저장합니다. 검색 시에도 동일한 해시 함수로 인덱스를 즉시 계산하여 데이터에 접근합니다.
-   **장점**: 데이터의 추가, 삭제, 검색 속도가 이론적으로 가장 빠릅니다.
-   **단점**: 해시 충돌(Collision, 서로 다른 데이터가 같은 해시 값을 갖는 현상)이 발생할 수 있으며, 이를 해결하기 위한 추가적인 로직이 필요합니다.
-   **시간 복잡도**: 평균 O(1) - 거의 즉시 검색이 가능합니다.
-   **Python의 활용**: Python의 `딕셔너리(dict)`와 `셋(set)`이 바로 해시 테이블을 기반으로 구현된 자료 구조입니다.

```python
# 파이썬 딕셔너리를 이용한 해시 검색 예시
student_scores = {'Alice': 85, 'Bob': 92, 'Charlie': 78}

# 'Bob'의 점수를 찾는 것은 내부적으로 해시 검색을 통해 O(1)에 가깝게 동작
bob_score = student_scores['Bob']
print(f"Bob's score: {bob_score}")
```

### 검색 알고리즘 비교 요약

| 알고리즘 | 정렬 필요 여부 | 시간 복잡도 (평균) | 주요 특징 |
| :--- | :---: | :---: | :--- |
| **순차 검색** | **불필요** | O(n) | 구현이 가장 간단하지만, 데이터가 많으면 느림. |
| **이진 검색** | **필수** | O(log n) | 매우 빠르지만, 데이터가 반드시 정렬되어 있어야 함. |
| **해시 검색** | **불필요** | O(1) | 이론상 가장 빠르며, Python의 `dict`와 `set`의 기반. |

---

## 3. 정렬(Sort) 알고리즘: 데이터를 가지런히

### 선택 정렬 (Selection Sort)

-   **개념**: 전체 데이터 중에서 **가장 작은 값(또는 가장 큰 값)을 찾아 맨 앞으로** 보내는 과정을 반복하는 정렬 방식입니다.
-   **동작 방식**:
    1.  0번 인덱스부터 시작하여, 전체 리스트에서 가장 작은 값을 찾습니다.
    2.  찾은 가장 작은 값을 0번 인덱스의 값과 교환(swap)합니다.
    3.  다음으로 1번 인덱스부터 시작하여, 남은 리스트에서 가장 작은 값을 찾아 1번 인덱스와 교환합니다.
    4.  이 과정을 리스트 끝까지 반복합니다.
-   **장점**: 구현이 직관적이고 간단합니다. 추가적인 메모리 공간이 거의 필요 없습니다(제자리 정렬, In-place sort).
-   **단점**: 데이터의 양이 많아지면 성능이 급격히 저하됩니다.
-   **시간 복잡도**: O(n²) - 데이터의 정렬 상태와 관계없이 항상 동일한 비교 횟수를 가집니다.

```python
def selection_sort(data_list):
    """리스트를 오름차순으로 선택 정렬합니다."""
    n = len(data_list)
    for i in range(n):
        # 현재 순회에서 가장 작은 값의 인덱스를 저장할 변수
        min_index = i
        # i+1부터 끝까지 순회하며 진짜 최솟값을 찾음
        for j in range(i + 1, n):
            if data_list[j] < data_list[min_index]:
                min_index = j
        
        # 찾은 최솟값을 현재 위치(i)의 값과 교환
        data_list[i], data_list[min_index] = data_list[min_index], data_list[i]
    
    return data_list

my_list = [64, 25, 12, 22, 11]
print(f"정렬 전: {my_list}")
sorted_list = selection_sort(my_list)
print(f"정렬 후: {sorted_list}")
```

### 정렬 알고리즘의 종류와 특징

선택 정렬 외에도 다양한 정렬 알고리즘이 있으며, 각각의 시간 복잡도와 특징이 다릅니다.

| 알고리즘 | 시간 복잡도 (평균) | 공간 복잡도 | 안정 정렬(Stable) | 특징 |
| :--- | :---: | :---: | :---: | :--- |
| **선택 정렬** | O(n²) | O(1) | ❌ | 구현이 간단하지만 비효율적. |
| **버블 정렬** | O(n²) | O(1) | ✅ | 인접한 원소를 계속 교환. 거의 정렬된 데이터에 비효율적. |
| **삽입 정렬** | O(n²) | O(1) | ✅ | 데이터를 하나씩 올바른 위치에 삽입. 거의 정렬된 데이터에 매우 효율적. |
| **병합 정렬** | O(n log n) | O(n) | ✅ | 분할 정복 기반. 안정적이지만 추가 메모리 필요. |
| **퀵 정렬** | O(n log n) | O(log n) | ❌ | 분할 정복 기반. 평균적으로 매우 빠르지만 최악의 경우 O(n²). |
| **팀소트(Timsort)** | O(n log n) | O(n) | ✅ | 병합 정렬과 삽입 정렬을 결합한 하이브리드 알고리즘. **Python의 내장 정렬(`sorted`, `.sort`)**에 사용됨. |

> **💡 안정 정렬(Stable Sort)이란?**
> 정렬 후에도 값이 같은 원소들의 상대적인 순서가 그대로 유지되는 정렬 방식을 의미합니다. 예를 들어, (A, 5), (B, 3), (C, 5)를 점수 순으로 안정 정렬하면 (B, 3), (A, 5), (C, 5)가 되어, 점수가 같은 A와 C의 원래 순서가 보존됩니다.

---

[⏮️ 이전 문서](./0429-Python정리.md) | [다음 문서 ⏭️](./0502_Python정리.md)
