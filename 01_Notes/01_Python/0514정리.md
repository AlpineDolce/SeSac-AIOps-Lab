# 🐍 Python 심화: 정규표현식과 가상환경 (Day 14)

> **이 문서의 목적**: 이 문서는 부트캠프 14일차에 학습한 **정규표현식(Regular Expression)**을 활용한 고급 문자열 처리 기술과, **가상환경(Virtual Environment)**을 이용한 체계적인 프로젝트 관리 방법을 깊이 있게 정리한 자료입니다. 복잡한 텍스트에서 원하는 정보를 정확히 찾아내고, 프로젝트별로 독립적인 개발 환경을 구축하여 안정성과 재현성을 확보하는 능력을 보여주는 것을 목표로 합니다.

---

## 목차

1.  [**정규표현식(Regex): 문자열 속 패턴을 지배하는 기술**](#1-정규표현식regex-문자열-속-패턴을-지배하는-기술)
    -   [정규표현식이란?](#11-정규표현식이란)
    -   [핵심 메타 문자와 패턴](#12-핵심-메타-문자와-패턴)
    -   [`re` 모듈의 주요 함수와 활용법](#13-re-모듈의-주요-함수와-활용법)
    -   [실전 정규표현식 패턴 예시](#14-실전-정규표현식-패턴-예시)
2.  [**가상환경: 프로젝트 격리의 정석**](#2-가상환경-프로젝트-격리의-정석)
    -   [왜 가상환경이 필요한가?](#21-왜-가상환경이-필요한가)
    -   [`venv` 기본 사용법: 생성, 활성화, 비활성화](#22-venv-기본-사용법-생성-활성화-비활성화)
    -   [`requirements.txt`를 이용한 의존성 관리](#23-requirementstxt를-이용한-의존성-관리)
    -   [다양한 가상환경 도구 비교](#24-다양한-가상환경-도구-비교)
3.  [**마무리 요약**](#3-마무리-요약)

---

## 1. 정규표현식(Regex): 문자열 속 패턴을 지배하는 기술

### 1.1. 정규표현식이란?

**정규표현식(Regular Expression, Regex)**은 복잡한 문자열 속에서 특정 **규칙(패턴)**을 찾아내어 텍스트를 검색, 추출, 치환하는 데 사용되는 강력한 도구입니다. 이메일 유효성 검사, 로그 파일 분석, 데이터 클리닝 등 다양한 분야에서 활용됩니다. Python에서는 `re` 표준 라이브러리를 통해 정규표현식을 사용할 수 있습니다.

### 1.2. 핵심 메타 문자와 패턴

정규표현식은 특별한 의미를 가진 **메타 문자**들의 조합으로 패턴을 만듭니다.

| 종류 | 메타 문자 | 설명 | 예시 |
| :--- | :--- | :--- | :--- |
| **기본 문자** | `.` | 줄바꿈(`\n`)을 제외한 모든 문자 하나 | `a.b` -> `acb`, `a*b` |
| **앵커** | `^`, `$` | `^`: 문자열 시작, `$`: 문자열 끝 | `^Hello` -> `Hello world` |
| **수량자** | `*`, `+`, `?` | `*`: 0회 이상, `+`: 1회 이상, `?`: 0회 또는 1회 | `a*b` -> `b`, `ab`, `aaab` |
| | `{n}`, `{n,m}` | `{n}`: n회, `{n,m}`: n회에서 m회 반복 | `\d{3}` -> `123` |
| **문자 클래스** | `[]`, `[^]` | `[]`: 괄호 안의 문자 중 하나, `[^]`: 제외 | `[aeiou]` -> `a`, `e` |
| **특수 시퀀스** | `\d`, `\w`, `\s` | `\d`: 숫자, `\w`: 단어(알파벳,숫자,_), `\s`: 공백 | `\d+` -> `12345` |
| | `\D`, `\W`, `\S` | 각각 `\d`, `\w`, `\s`의 반대 | `\D+` -> `abc` |
| **그룹핑** | `()` | 패턴을 그룹으로 묶어 추출하거나 수량자 적용 | `(ab)+` -> `ab`, `abab` |
| **경계** | `\b` | 단어의 경계 (공백, 문장 부호 등) | `\bcat\b` -> `cat` (O), `catch` (X) |

### 1.3. `re` 모듈의 주요 함수와 활용법

-   **`re.search(pattern, string)`**: 문자열 전체에서 패턴과 일치하는 **첫 번째** 부분을 찾아 `Match` 객체로 반환합니다. 없으면 `None`을 반환합니다.
-   **`re.match(pattern, string)`**: 문자열 **시작부터** 패턴이 일치하는지 확인합니다. `search`와 달리 시작 부분이 다르면 찾지 못합니다.
-   **`re.findall(pattern, string)`**: 패턴과 일치하는 **모든** 부분을 찾아 **리스트**로 반환합니다.
-   **`re.sub(pattern, repl, string)`**: 패턴과 일치하는 부분을 `repl` 문자열로 **치환**합니다.
-   **`re.compile(pattern)`**: 정규식 패턴을 **컴파일**하여 `RegexObject`를 생성합니다. 동일한 패턴을 여러 번 사용할 때 성능을 향상시킬 수 있습니다.

```python
import re

text = "제 이메일은 user-01@example.com 이고, 다른 이메일은 test.user@gmail.com 입니다."

# compile: 패턴을 재사용하기 위해 컴파일
email_pattern = re.compile(r"[\w\.-]+@[\w\.-]+\.\w+")

# findall: 모든 이메일 주소 추출
emails = email_pattern.findall(text)
print(f"추출된 이메일: {emails}")
# 출력: ['user-01@example.com', 'test.user@gmail.com']

# sub: 이메일 주소 마스킹
masked_text = email_pattern.sub("[이메일 주소]", text)
print(f"마스킹된 텍스트: {masked_text}")
# 출력: 제 이메일은 [이메일 주소] 이고, 다른 이메일은 [이메일 주소] 입니다.
```

### 1.4. 실전 정규표현식 패턴 예시

| 용도 | 패턴 예시 | 설명 |
| :--- | :--- | :--- |
| **사용자 ID** | `^[a-z0-9_]{5,20}$` | 5~20자의 영소문자, 숫자, 밑줄(`_`)로만 구성 |
| **비밀번호** | `^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[A-Za-z\d]{8,}$` | 8자 이상, 영소문자, 대문자, 숫자가 최소 1개씩 포함 |
| **휴대폰 번호** | `^01[016789]-\d{3,4}-\d{4}$` | `010-1234-5678` 또는 `011-123-4567` 형식 |
| **날짜 (YYYY-MM-DD)** | `^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$` | `2023-06-07`과 같은 형식 (월/일 유효성 일부 포함) |
| **URL** | `https?://(?:[-\w.]|(?:%[\da-fA-F]{2}))+` | `http` 또는 `https`로 시작하는 기본 URL |
| **HTML 태그 제거** | `<[^>]+>` | 여는 태그, 닫는 태그, 속성을 포함한 모든 HTML 태그 |

---

## 2. 가상환경: 프로젝트 격리의 정석

### 2.1. 왜 가상환경이 필요한가?

가상환경은 **프로젝트마다 독립된 Python 실행 환경을 만들어주는 도구**입니다.

-   **의존성 충돌 방지**: 프로젝트 A는 `requests 2.0`을, 프로젝트 B는 `requests 3.0`을 필요로 할 때, 시스템에 하나의 버전만 설치하면 다른 프로젝트가 오작동합니다. 가상환경은 각 프로젝트가 자신만의 패키지 버전을 갖도록 격리하여 이 문제를 해결합니다.
-   **프로젝트 재현성**: `requirements.txt` 파일을 통해 프로젝트에 필요한 패키지 목록을 정확히 명시할 수 있어, 다른 개발자나 배포 서버에서도 동일한 환경을 쉽게 구축할 수 있습니다.

### 2.2. `venv` 기본 사용법: 생성, 활성화, 비활성화

Python 3.3부터 `venv` 모듈이 표준 라이브러리로 내장되어 있어 별도 설치 없이 사용할 수 있습니다.

**1. 가상환경 생성**
```bash
# .venv 라는 이름의 가상환경 폴더 생성
python -m venv .venv
```

**2. 가상환경 활성화**
-   **Windows**:
    ```bash
    .\.venv\Scripts\activate
    ```
-   **macOS / Linux**:
    ```bash
    source .venv/bin/activate
    ```
    > 활성화되면 터미널 프롬프트 앞에 `(.venv)`가 표시됩니다.

**3. 가상환경 비활성화**
```bash
deactivate
```

### 2.3. `requirements.txt`를 이용한 의존성 관리

협업과 배포의 필수 요소입니다. 현재 가상환경에 설치된 패키지 목록을 파일로 저장하고, 이 파일을 이용해 다른 환경에 동일한 패키지들을 한 번에 설치할 수 있습니다.

**1. 패키지 목록 저장하기**
```bash
# 현재 환경의 패키지 목록을 requirements.txt 파일로 저장
pip freeze > requirements.txt
```

**2. 파일로부터 패키지 설치하기**
```bash
# requirements.txt 파일에 명시된 모든 패키지를 설치
pip install -r requirements.txt
```

**3. 예시 디렉토리 구조**
```
my_project/
├── venv/                # 가상환경 폴더 (.gitignore 등 Git에 포함하지 않음)
├── requirements.txt     # 설치된 패키지 목록
├── main.py              # 프로젝트 코드
```


```
# .gitignore
venv/
```
> **💡 Best Practice**: 프로젝트를 Git으로 관리할 때, 가상환경 폴더(`.venv`)는 용량이 크고 OS마다 구조가 다르므로 `.gitignore`에 추가하여 저장소에 포함되지 않도록 합니다. 대신 `requirements.txt` 파일을 저장소에 포함시켜 다른 환경에서도 의존성을 설치할 수 있도록 합니다.

### 2.4. 다양한 가상환경 도구 비교

| 도구 | 주요 용도 | 특징 | 추천 상황 |
| :--- | :--- | :--- | :--- |
| **`venv`** | **기본 가상환경** | Python 표준 내장. 가볍고 간단함. | 대부분의 Python 3 프로젝트 |
| **`pyenv`** | **Python 버전 관리** | 다양한 Python 버전(3.8, 3.9, 3.10 등)을 쉽게 설치하고 전환. | 여러 Python 버전으로 테스트해야 할 때 |
| **`Poetry`** | **의존성 관리 및 패키징** | `pyproject.toml` 기반의 현대적인 의존성 관리, 빌드, 배포 자동화. | 라이브러리 배포나 엄격한 의존성 관리가 필요할 때 |
| **`Conda`** | **패키지 및 환경 관리** | Python 뿐만 아니라 C, R 등 비-Python 패키지까지 통합 관리. | 데이터 과학, 머신러닝 등 과학 컴퓨팅 분야 |

---

## 3. 마무리 요약

| 개념 | 핵심 설명 | 주요 키워드 |
| :--- | :--- | :--- |
| **정규표현식** | 문자열에서 특정 패턴을 검색, 추출, 치환하는 도구 | `re`, `pattern`, `match`, `search`, `findall`, `sub` |
| **가상환경** | 프로젝트별로 독립된 Python 패키지 및 실행 환경 | `venv`, `pip`, `requirements.txt`, 의존성 관리 |

---

[⏮️ 이전 문서](./0513_Python정리.md) | [다음 문서 ⏭️](../../02_SQL/01_organize/0515_SQL정리.md)