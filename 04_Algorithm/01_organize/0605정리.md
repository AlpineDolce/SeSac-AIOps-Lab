# 🧮 알고리즘 기초: 정렬과 트리 (Day 26)

> 이 문서는 부트캠프에서 학습한 주요 알고리즘과 자료구조에 대한 핵심 이론과 개념을 정리한 자료입니다. 정렬 알고리즘(선택, 퀵, 버블 정렬)과 트리 자료구조(일반 트리, 이진 탐색 트리, 트리 순회)에 초점을 맞춰 각 개념의 원리, 동작 방식, 구현 예시, 그리고 특징을 상세히 다룹니다. 본 문서를 통해 알고리즘과 자료구조에 대한 이해를 높이고, 실제 문제 해결에 적용하는 데 도움이 되기를 바랍니다.

---

## 목차

1.  [**선택 정렬 (Selection Sort)**](#1-선택-정렬-selection-sort)
    -   [1.1 개념 및 특징](#11-개념-및-특징)
    -   [1.2 동작 방식 예시](#12-동작-방식-예시)
    -   [1.3 Python 구현](#13-python-구현)
    -   [1.4 특징 요약](#14-특징-요약)
2.  [**퀵 정렬 (Quick Sort)**](#2-퀵-정렬-quick-sort)
    -   [2.1 개념 및 특징](#21-개념-및-특징)
    -   [2.2 동작 방식 예시](#22-동작-방식-예시)
    -   [2.3 Python 구현](#23-python-구현)
    -   [2.4 특징 요약](#24-특징-요약)
3.  [**버블 정렬 (Bubble Sort)**](#3-버블-정렬-bubble-sort)
    -   [3.1 개념 설명](#31-개념-설명)
    -   [3.2 동작 방식 예시](#32-동작-방식-예시)
    -   [3.3 Python 구현](#33-python-구현)
    -   [3.4 특징 요약](#34-특징-요약)
4.  [**정렬 알고리즘 비교**](#4-정렬-알고리즘-비교)
5.  [**트리 (Tree)**](#5-트리-tree)
    -   [5.1 트리란?](#51-트리란)
    -   [5.2 트리 기본 용어](#52-트리-기본-용어)
    -   [5.3 트리 구조 예시](#53-트리-구조-예시)
    -   [5.4 Python 구현 예제](#54-python-구현-예제)
    -   [5.5 트리 시각화](#55-트리-시각화)
    -   [5.6 트리 요약](#56-트리-요약)
6.  [**이진 탐색 트리 (Binary Search Tree, BST)**](#6-이진-탐색-트리-binary-search-tree-bst)
    -   [6.1 이진 탐색 트리란?](#61-이진-탐색-트리란)
    -   [6.2 이진 탐색 트리 구조 예시](#62-이진-탐색-트리-구조-예시)
    -   [6.3 BST Python 구현](#63-bst-python-구현)
    -   [6.4 BST 요약](#64-bst-요약)
    -   [6.5 시각 자료](#65-시각-자료)
7.  [**이진 탐색 트리의 순회 (Traversal)**](#7-이진-탐색-트리의-순회-traversal)
    -   [7.1 순회 종류와 특징](#71-순회-종류와-특징)
    -   [7.2 전위 순회 (Preorder Traversal)](#72-전위-순회-preorder-traversal)
    -   [7.3 중위 순회 (Inorder Traversal)](#73-중위-순회-inorder-traversal)
    -   [7.4 후위 순회 (Postorder Traversal)](#74-후위-순회-postorder-traversal)
    -   [7.5 순회 방식별 노드 방문 순서 비교](#75-순회-방식별-노드-방문-순서-비교)
    -   [7.6 순회 방식의 시각적 이해](#76-순회-방식의-시각적-이해)
    -   [7.7 순회 방식의 활용 예시](#77-순회-방식의-활용-예시)
    -   [7.8 참고: 순회 방식의 비재귀(스택) 구현](#78-참고-순회-방식의-비재귀스택-구현)
    -   [7.9 정리 요약](#79-정리-요약)
8.  [**이진 트리의 재귀 및 반복 순회 구현 상세**](#8-이진-트리의-재귀-및-반복-순회-구현-상세)
    -   [8.1 재귀 순회 구현의 이해](#81-재귀-순회-구현의-이해)
    -   [8.2 반복(Iterative) 순회 구현의 이해](#82-반복iterative-순회-구현의-이해)
    -   [8.3 반복 전위 순회 (Iterative Preorder Traversal)](#83-반복-전위-순회-iterative-preorder-traversal)
    -   [8.4 반복 후위 순회 (Iterative Postorder Traversal)](#84-반복-후위-순회-iterative-postorder-traversal)
9.  [**이진 트리의 배열 표현**](#9-이진-트리의-배열-표현)
    -   [9.1 배열 구조 및 인덱스 계산](#91-배열-구조-및-인덱스-계산)
    -   [9.2 자식 노드와 부모 노드 찾기 구현](#92-자식-노드와-부모-노드-찾기-구현)
10. [**트리를 이용한 전위, 중위, 후위 계산 방법**](#10-트리를-이용한-전위-중위-후위-계산-방법)
    -   [10.1 이진 트리에서의 수식 표현 및 노드 정의](#101-이진-트리에서의-수식-표현-및-노드-정의)
    -   [10.2 순회별 계산 방법 및 구현](#102-순회별-계산-방법-및-구현)
    -   [10.3 전체 예시: 수식 트리 구축 및 계산](#103-전체-예시-수식-트리-구축-및-계산)
11. [**트리와 이진 탐색 트리 비교**](#11-트리와-이진-탐색-트리-비교)

---

## 1. 선택 정렬 (Selection Sort)

### 1.1 개념 및 특징

선택 정렬(Selection Sort)은 **가장 작은 값(또는 가장 큰 값)**을 **찾아서 앞으로 보내는 작업을 반복**하는 간단한 정렬 알고리즘입니다.

*   **시간 복잡도**: O(n²)
    두 개의 중첩 반복문이 모든 요소를 비교하기 때문입니다.

*   **공간 복잡도**: O(1)
    추가 공간 없이 **제자리에서(in-place)** 정렬합니다.

---

### 1.2 동작 방식 예시

예: `[64, 25, 12, 22, 11]` 이라는 리스트가 있을 때,

1. 전체에서 **가장 작은 수 11**을 찾아서 첫 번째(맨 앞) 값 64와 교환
   → `[11, 25, 12, 22, 64]`
2. 나머지 리스트에서 **가장 작은 수 12**를 찾아서 두 번째 값 25와 교환
   → `[11, 12, 25, 22, 64]`
3. 다음은 **22**를 찾아서 25와 교환
   → `[11, 12, 22, 25, 64]`
4. 다음은 이미 정렬되어 있으므로 그대로 진행
   → `[11, 12, 22, 25, 64]` (정렬 완료)

---

### 1.3 Python 구현

선택 정렬의 Python 구현은 다음과 같습니다. 두 개의 반복문을 사용하여 최소값을 찾아 정렬하는 방식입니다.

```python
def selection_sort(arr):
    # 리스트의 처음부터 끝까지 반복합니다.
    # i는 현재 정렬될 요소의 위치를 나타냅니다.
    for i in range(len(arr)):
        min_idx = i  # 현재 위치(i)를 가장 작은 값의 인덱스라고 가정합니다.

        # 현재 위치(i) 이후의 요소들 중에서 가장 작은 값을 찾습니다.
        # j는 비교 대상 요소의 인덱스를 나타냅니다.
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min_idx]:  # 만약 현재 최소값(arr[min_idx])보다 더 작은 값을 발견하면
                min_idx = j  # 그 값의 인덱스(j)를 새로운 최소값 인덱스로 업데이트합니다.

        # 현재 위치(i)의 값과 찾은 최소값 위치(min_idx)의 값을 교환합니다.
        # 이렇게 하면 가장 작은 값이 올바른 위치(i)로 이동하게 됩니다.
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

    return arr

# 실행 예시
data = [64, 25, 12, 22, 11]
print(selection_sort(data))  # 출력: [11, 12, 22, 25, 64]
```
---

### 1.4 특징 요약

| 항목         | 내용                         |
| ---------- | -------------------------- |
| **정렬 방식**  | 가장 작은(또는 큰) 값을 선택해서 앞으로 보냄 |
| **시간 복잡도** | O(n²) — 느림                 |
| **공간 복잡도** | O(1) — 추가 메모리 없음           |
| **장점**     | 구현이 매우 간단함                 |
| **단점**     | 비효율적이라 큰 데이터에는 부적합         |
| **안정 정렬?** | ❌ 아니요 (같은 값의 순서가 바뀔 수 있음)  |

---

## 2. 퀵 정렬 (Quick Sort)

### 2.1 개념 및 특징

**퀵 정렬(Quick Sort)** 은 **분할 정복(Divide and Conquer)** 방식을 기반으로 하는 고효율 정렬 알고리즘입니다. 이 알고리즘은 다음과 같은 단계로 데이터를 정렬합니다:

1.  **피벗(Pivot) 선택**: 리스트 내에서 하나의 요소를 기준(피벗)으로 선택합니다.
2.  **분할 (Partition)**: 피벗을 기준으로 리스트를 두 개의 부분 리스트로 나눕니다. 피벗보다 작은 값들은 피벗의 왼쪽으로, 피벗보다 크거나 같은 값들은 피벗의 오른쪽으로 이동시킵니다.
3.  **재귀 정렬**: 이렇게 분할된 두 부분 리스트에 대해 재귀적으로 퀵 정렬을 다시 적용합니다.
4.  **결합 (Combine)**: 부분 리스트들이 정렬되면, 피벗을 중심으로 정렬된 두 부분 리스트를 합쳐 최종 정렬된 리스트를 완성합니다. (실제 구현에서는 별도의 병합 과정 없이 제자리 정렬됩니다.)

---

### 2.1.1 핵심 개념

퀵 정렬은 다음 세 가지 핵심 개념을 기반으로 동작하며, 이들을 이해하는 것이 중요합니다:

*   **분할 정복 (Divide and Conquer)**:
    *   **분할 (Divide)**: 전체 문제를 작은 하위 문제로 나눕니다. 퀵 정렬에서는 피벗을 기준으로 리스트를 두 개의 부분 리스트로 나눕니다.
    *   **정복 (Conquer)**: 나눠진 하위 문제들을 재귀적으로 해결합니다. 각 부분 리스트에 대해 다시 퀵 정렬을 적용합니다.
    *   **결합 (Combine)**: 해결된 하위 문제들의 결과를 합쳐 원래 문제의 해답을 얻습니다. 퀵 정렬에서는 정렬된 부분 리스트와 피벗을 합쳐 최종 정렬된 리스트를 만듭니다.

*   **재귀 호출 (Recursion)**:
    함수가 자기 자신을 호출하여 문제를 반복적으로 해결하는 방식입니다. 퀵 정렬은 분할된 부분 리스트에 대해 다시 `quick_sort` 함수를 호출함으로써 재귀적으로 정렬을 수행합니다. 베이스 케이스(리스트의 길이가 1 이하일 때)에 도달하면 재귀 호출이 종료됩니다.

*   **피벗 (Pivot)**:
    리스트를 두 부분으로 나누는 기준이 되는 값입니다. 피벗의 선택은 퀵 정렬의 성능에 큰 영향을 미칩니다. 일반적으로 첫 번째 요소, 마지막 요소, 중간 요소, 또는 무작위 요소를 피벗으로 선택합니다.

---

### 2.2 동작 방식 예시

예시: `[64, 25, 12, 22, 11]` 리스트를 퀵 정렬하는 과정을 단계별로 살펴보겠습니다. 여기서는 **첫 번째 요소를 피벗으로 선택**하는 방식을 사용합니다.

---

#### 1. 첫 번째 분할 (Initial Partition)

*   **초기 배열**: `[64, 25, 12, 22, 11]`
*   **피벗**: `64`

```
[ 64 ]  [ 25, 12, 22, 11 ]  [ ]
  ↑         ↑                 ↑
피벗      왼쪽 (작은 값)      오른쪽 (크거나 같은 값)
```

*   **설명**: `64`를 피벗으로 선택하고, 나머지 요소들을 `64`보다 작은 값(`left`)과 크거나 같은 값(`right`)으로 나눕니다.
*   **다음 단계**: `left` 배열 `[25, 12, 22, 11]`에 대해 재귀적으로 퀵 정렬을 진행합니다.

---

#### 2. 두 번째 분할 (Recursive Call on `[25, 12, 22, 11]`)

*   **현재 처리 배열**: `[25, 12, 22, 11]`
*   **피벗**: `25`

```
[ 25 ]  [ 12, 22, 11 ]  [ ]
  ↑         ↑             ↑
피벗      왼쪽          오른쪽
```

*   **설명**: `25`를 피벗으로 선택하고, `[12, 22, 11]`을 `25`보다 작은 값(`left`)으로, `[]`을 크거나 같은 값(`right`)으로 나눕니다.
*   **다음 단계**: `left` 배열 `[12, 22, 11]`에 대해 재귀적으로 퀵 정렬을 진행합니다.

---

#### 3. 세 번째 분할 (Recursive Call on `[12, 22, 11]`)

*   **현재 처리 배열**: `[12, 22, 11]`
*   **피벗**: `12`

```
[ 12 ]  [ 11 ]  [ 22 ]
  ↑       ↑       ↑
피벗    왼쪽    오른쪽
```

*   **설명**: `12`를 피벗으로 선택하고, `[11]`을 `12`보다 작은 값(`left`)으로, `[22]`를 크거나 같은 값(`right`)으로 나눕니다.
*   **다음 단계**: `[11]`과 `[22]`는 길이가 1이므로 더 이상 분할하지 않고 정렬된 상태로 반환됩니다.

---

#### 4. 병합 (Combine Phase - from innermost calls)

*   `[11]`과 `[22]`가 정렬된 상태로 반환됩니다.
*   세 번째 분할의 결과는 `quick_sort([11]) + [12] + quick_sort([22])`가 되어 다음과 같이 병합됩니다.

```
[ 11 ] + [ 12 ] + [ 22 ]  =>  [ 11, 12, 22 ]
```

---

#### 5. 두 번째 병합 (Combine Phase - next level up)

*   두 번째 분할의 결과는 `quick_sort([12, 22, 11]) + [25] + quick_sort([])`가 됩니다.
*   `quick_sort([12, 22, 11])`의 결과는 `[11, 12, 22]`이므로, 다음과 같이 병합됩니다.

```
[ 11, 12, 22 ] + [ 25 ] + [ ]  =>  [ 11, 12, 22, 25 ]
```

---

#### 6. 최종 병합 (Final Combine Phase)

*   첫 번째 분할의 결과는 `quick_sort([25, 12, 22, 11]) + [64] + quick_sort([])`가 됩니다.
*   `quick_sort([25, 12, 22, 11])`의 결과는 `[11, 12, 22, 25]`이므로, 최종적으로 다음과 같이 병합됩니다.

```
[ 11, 12, 22, 25 ] + [ 64 ] + [ ]  =>  [ 11, 12, 22, 25, 64 ]
```

이 과정을 통해 리스트가 완전히 정렬됩니다.

---

### 2.3 Python 구현

퀵 정렬의 Python 구현은 재귀 호출을 사용하여 리스트를 분할하고 정복하는 방식으로 이루어집니다. 다음 코드는 첫 번째 요소를 피벗으로 사용하는 간단한 퀵 정렬 구현입니다.

```python
def quick_sort(arr):
    # 베이스 케이스: 리스트의 길이가 1 이하이면 이미 정렬된 상태이므로 그대로 반환합니다.
    # 재귀 호출의 종료 조건이 됩니다.
    if len(arr) <= 1:
        return arr

    pivot = arr[0]  # 리스트의 첫 번째 요소를 피벗(기준값)으로 설정합니다.

    # 리스트의 나머지 요소들(arr[1:]부터)을 순회하며 피벗과 비교합니다.
    # 리스트 컴프리헨션을 사용하여 피벗보다 작은 값들과 크거나 같은 값들을 각각 새로운 리스트로 분리합니다.
    left = [x for x in arr[1:] if x < pivot]  # 피벗보다 작은 값들을 모은 리스트
    right = [x for x in arr[1:] if x >= pivot] # 피벗보다 크거나 같은 값들을 모은 리스트

    # 재귀 케이스: 분할된 `left` 리스트와 `right` 리스트를 각각 다시 퀵 정렬합니다.
    # 정렬된 `left` 리스트, 피벗, 정렬된 `right` 리스트를 합쳐 최종 정렬된 리스트를 반환합니다.
    return quick_sort(left) + [pivot] + quick_sort(right)

# 실행 예시
data = [64, 25, 12, 22, 11]
print(quick_sort(data))  # 출력: [11, 12, 22, 25, 64]
```

---

### 2.4 특징 요약

| 항목         | 내용                                  |
| ---------- | ----------------------------------- |
| **정렬 방식**  | 분할 정복 (Divide and Conquer)          |
| **시간 복잡도** | 평균: O(n log n), 최악: O(n²) (피벗이 나쁘면) |
| **공간 복잡도** | O(n) (리스트 분할을 위해 추가 공간 사용)          |
| **장점**     | 빠르고 효율적 (실제로 많이 사용됨)                |
| **단점**     | 피벗 선택이 나쁘면 성능 저하                    |
| **안정 정렬?** | ❌ 아니요 (같은 값의 순서가 바뀔 수 있음)           |

---


## 3. 버블 정렬 (Bubble Sort)

### 3.1 개념 설명

* 버블 정렬은 **인접한 두 값을 비교**해서 큰 값을 **오른쪽(뒤)**으로 보내는 방식입니다.
* 이 과정을 반복하면 **가장 큰 값이 맨 뒤로 "둥둥" 올라가는 느낌**이 납니다.
  → 마치 물속에서 **거품이 위로 올라가는 모습** 같다고 해서 **Bubble Sort**라고 부릅니다.

---

### 3.2 동작 방식 예시

예시: `[64, 25, 12, 22, 11]` 리스트를 버블 정렬하는 과정을 단계별로 살펴보겠습니다.

#### 🔁 첫 번째 반복 (Pass 1)

**목표**: 가장 큰 값 `64`를 배열의 맨 뒤로 이동시킵니다.

`[64, 25, 12, 22, 11]`

| 비교 위치 | 비교 값   | 교환 여부 | 결과 배열                  | 설명                                       |
| :------ | :------ | :------ | :----------------------- | :--------------------------------------- |
| 0, 1    | 64, 25  | ✅ 교환  | `[25, 64, 12, 22, 11]`   | `64 > 25`이므로 교환. `64`가 오른쪽으로 이동. |
| 1, 2    | 64, 12  | ✅ 교환  | `[25, 12, 64, 22, 11]`   | `64 > 12`이므로 교환. `64`가 오른쪽으로 이동. |
| 2, 3    | 64, 22  | ✅ 교환  | `[25, 12, 22, 64, 11]`   | `64 > 22`이므로 교환. `64`가 오른쪽으로 이동. |
| 3, 4    | 64, 11  | ✅ 교환  | `[25, 12, 22, 11, 64]`   | `64 > 11`이므로 교환. `64`가 맨 뒤로 이동. |

➡ **결과**: `64`가 배열의 맨 뒤(`arr[4]`)로 이동하여 제자리를 찾았습니다.
`[25, 12, 22, 11, 64]`

---

#### 🔁 두 번째 반복 (Pass 2)

**목표**: 남은 요소들 `[25, 12, 22, 11]` 중에서 가장 큰 값 `25`를 `64`의 바로 앞으로 이동시킵니다.

`[25, 12, 22, 11, 64]`

| 비교 위치 | 비교 값   | 교환 여부 | 결과 배열                  | 설명                                       |
| :------ | :------ | :------ | :----------------------- | :--------------------------------------- |
| 0, 1    | 25, 12  | ✅ 교환  | `[12, 25, 22, 11, 64]`   | `25 > 12`이므로 교환. `25`가 오른쪽으로 이동. |
| 1, 2    | 25, 22  | ✅ 교환  | `[12, 22, 25, 11, 64]`   | `25 > 22`이므로 교환. `25`가 오른쪽으로 이동. |
| 2, 3    | 25, 11  | ✅ 교환  | `[12, 22, 11, 25, 64]`   | `25 > 11`이므로 교환. `25`가 `64`의 바로 앞으로 이동. |

➡ **결과**: `25`가 `arr[3]` 위치로 이동하여 제자리를 찾았습니다.

`[12, 22, 11, 25, 64]`

---

#### 🔁 세 번째 반복 (Pass 3)

**목표**: 남은 요소들 `[12, 22, 11]` 중에서 가장 큰 값 `22`를 `25`의 바로 앞으로 이동시킵니다.

`[12, 22, 11, 25, 64]`

| 비교 위치 | 비교 값   | 교환 여부 | 결과 배열                  | 설명                                       |
| :------ | :------ | :------ | :----------------------- | :--------------------------------------- |
| 0, 1    | 12, 22  | ❌ 그대로 | `[12, 22, 11, 25, 64]`   | `12 < 22`이므로 교환하지 않습니다.       |
| 1, 2    | 22, 11  | ✅ 교환  | `[12, 11, 22, 25, 64]`   | `22 > 11`이므로 교환. `22`가 `25`의 바로 앞으로 이동. |

➡ **결과**: `22`가 `arr[2]` 위치로 이동하여 제자리를 찾았습니다.
`[12, 11, 22, 25, 64]`

---

#### 🔁 네 번째 반복 (Pass 4)

**목표**: 남은 요소들 `[12, 11]` 중에서 가장 큰 값 `12`를 `22`의 바로 앞으로 이동시킵니다.

`[12, 11, 22, 25, 64]`

| 비교 위치 | 비교 값   | 교환 여부 | 결과 배열                  | 설명                                       |
| :------ | :------ | :------ | :----------------------- | :--------------------------------------- |
| 0, 1    | 12, 11  | ✅ 교환  | `[11, 12, 22, 25, 64]`   | `12 > 11`이므로 교환. `12`가 `22`의 바로 앞으로 이동. |

➡ **결과**: `12`가 `arr[1]` 위치로 이동하여 제자리를 찾았습니다.

`[11, 12, 22, 25, 64]`

---

### 3.2.5 최종 정렬 결과

모든 반복이 완료되면, 배열은 다음과 같이 완전히 정렬됩니다:

```python
[11, 12, 22, 25, 64]
```

---

### 3.3 Python 구현

버블 정렬의 Python 구현은 중첩된 반복문을 사용하여 인접한 요소들을 비교하고 교환하는 방식으로 이루어집니다. 다음 코드는 버블 정렬의 기본적인 구현을 보여줍니다.

```python
def bubble_sort(arr):
    n = len(arr)  # 배열의 총 길이를 저장합니다.

    # 외부 루프: 배열의 모든 요소에 대해 한 번씩 "가장 큰 값"을 제자리에 놓는 과정을 반복합니다.
    # 각 반복마다 가장 큰 값이 배열의 끝으로 이동하므로, 다음 반복에서는 그 부분을 제외하고 비교합니다.
    for i in range(n):
        # 내부 루프: 인접한 두 요소를 비교하고 필요하면 교환합니다.
        # `n - i - 1`은 이미 정렬된 마지막 `i`개의 요소를 제외하고 비교 범위를 줄입니다.
        for j in range(0, n - i - 1):
            # 현재 요소(arr[j])가 다음 요소(arr[j+1])보다 크면
            if arr[j] > arr[j + 1]:
                # 두 요소의 위치를 교환합니다. (큰 값을 오른쪽으로 이동)
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                # 예: arr = [25, 64] → 교환 후 arr = [64, 25]

    # 모든 반복이 끝나면 정렬이 완료된 배열을 반환합니다.
    return arr

# 실행 예시
data = [64, 25, 12, 22, 11]
print(bubble_sort(data))  # 출력: [11, 12, 22, 25, 64]
```

---

### 3.4 특징 요약

| 항목     | 내용                                      |
| ------ | --------------------------------------- |
| 정렬 방식  | 인접한 두 값을 비교하여 **큰 값을 뒤로 보내는 방식**        |
| 시간 복잡도 | 평균: `O(n²)`, 최악: `O(n²)`                |
| 공간 복잡도 | `O(1)` — **추가 메모리 없이 제자리(in-place) 정렬** |
| 장점     | ✅ **구현이 매우 쉬움**, 직관적이며 동작 방식이 명확함       |
| 단점     | ❌ **성능이 매우 느림**, 실무에서는 거의 사용되지 않음       |
| 안정 정렬? | ✅ **예** — 같은 값을 가진 요소의 순서가 **변하지 않음**   |

---

## 4. 정렬 알고리즘 비교


| 항목         | 선택 정렬 (Selection Sort) | 퀵 정렬 (Quick Sort)         | 버블 정렬 (Bubble Sort)    |
| ---------- | ---------------------- | ------------------------- | ---------------------- |
| **정렬 방식**  | 가장 작은 값을 선택해 앞으로 이동    | 피벗 기준으로 좌우로 분할 & 재귀 정렬    | 인접한 값끼리 비교해 큰 값을 뒤로 이동 |
| **시간 복잡도** | O(n²)                  | 평균 O(n log n), 최악 O(n²)   | O(n²)                  |
| **공간 복잡도** | O(1) (제자리 정렬)          | O(n) (리스트 분할 or 재귀 스택 사용) | O(1)                   |
| **정렬 안정성** | ❌ (같은 값 순서 보장 안됨)      | ❌ (기본 구현은 불안정)            | ✅ (같은 값 순서 유지)         |
| **장점**     | 구현 간단, 추가 공간 없음        | 빠르고 효율적, 실전에서 많이 사용됨      | 원리 직관적, 학습용에 적합        |
| **단점**     | 느림 (모든 경우 O(n²))       | 피벗 선택이 나쁘면 성능 급감          | 느림 (효율 낮음)             |
| **대표 비유**  | 줄 세우기: 가장 작은 사람을 앞에    | 기준점 잡고 좌우로 나눠 정렬          | 거품처럼 큰 값이 뒤로 밀려남       |



---

## 5. 트리 (Tree)

### 5.1 트리란?

* **트리(Tree)**는 **계층적(Hierarchical)** 구조를 가지는 **비선형 자료구조**입니다.
* `노드(Node)`와 `간선(Edge)`으로 구성되며, **부모-자식 관계**로 이루어져 있습니다.
* 실제 예:
  * 📁 폴더 구조
  * 📊 조직도
  * 📚 데이터베이스 인덱스
  * 🔍 탐색 알고리즘

---

### 5.2 트리 기본 용어

| 용어          | 설명                                           |
| ----------- | -------------------------------------------- |
| **루트 노드**   | 트리의 시작점 (최상위 노드)                             |
| **부모 노드**   | 어떤 노드의 바로 위에 있는 노드                           |
| **자식 노드**   | 부모 노드에 연결된 하위 노드                             |
| **형제 노드**   | 같은 부모를 공유하는 노드들                              |
| **리프 노드**   | 자식이 없는 노드 (끝 노드)                             |
| **서브트리**    | 특정 노드를 루트로 가지는 작은 트리 구조                      |
| **높이 / 깊이** | 루트부터 특정 노드까지의 거리 (루트의 깊이는 0, 자식으로 갈수록 1씩 증가) |

---

### 5.3 트리 구조 예시

```plaintext
        1         ← 루트 노드
       / \
      2   3
     / \   \
    4   5   6   ← 리프 노드들
```

* 1: 루트 노드
* 2, 3: 1의 자식 (2와 3은 형제)
* 4, 5: 2의 자식
* 6: 3의 자식
* 4, 5, 6: 리프 노드 (자식 없음)

---

### 5.4 Python 구현 예제

트리는 노드와 간선으로 구성된 계층적 자료구조입니다. Python에서는 클래스를 사용하여 트리의 노드를 정의하고, 이 노드들을 연결하여 트리를 구성할 수 있습니다. 다음 예제는 이진 트리의 노드 클래스를 정의하고, 간단한 트리를 구성한 후 전위 순회(Preorder Traversal)를 수행하는 방법을 보여줍니다.

```python
# Node 클래스 정의
# 각 노드는 데이터를 저장하고, 왼쪽 자식과 오른쪽 자식에 대한 참조를 가집니다.
class Node:
    def __init__(self, data):
        self.data = data         # 노드가 저장할 값
        self.left = None         # 왼쪽 자식 노드에 대한 참조 (초기값은 None)
        self.right = None        # 오른쪽 자식 노드에 대한 참조 (초기값은 None)

# 트리 구성
# 위에서 정의한 Node 클래스를 사용하여 트리를 수동으로 구성합니다.
# 이진 트리의 예시 구조를 따릅니다.
root = Node(1)          # 루트 노드 생성
root.left = Node(2)     # 루트의 왼쪽 자식
root.right = Node(3)    # 루트의 오른쪽 자식

root.left.left = Node(4)    # 2의 왼쪽 자식
root.left.right = Node(5)   # 2의 오른쪽 자식

root.right.right = Node(6)  # 3의 오른쪽 자식

# 전위 순회 (Preorder Traversal) 함수 정의
# 전위 순회는 '루트 -> 왼쪽 자식 -> 오른쪽 자식' 순서로 노드를 방문합니다.
def preorder(node):
    if node:  # 현재 노드가 None이 아니면 (즉, 노드가 존재하면)
        print(node.data, end=' ')     # 1. 현재 노드의 데이터를 출력 (루트 방문)
        preorder(node.left)           # 2. 왼쪽 자식 노드에 대해 재귀적으로 전위 순회 호출
        preorder(node.right)          # 3. 오른쪽 자식 노드에 대해 재귀적으로 전위 순회 호출

# 전위 순회 실행
print("\n--- 트리 전위 순회 결과 ---")
preorder(root)  # 출력: 1 2 4 5 3 6
print() # 줄바꿈을 위해 추가
```

---

### 5.5 트리 시각화

트리는 추상적인 개념이므로 시각적으로 이해하는 것이 중요합니다. 아래 이미지는 일반적인 이진 트리의 구조를 보여줍니다. 각 원은 노드를 나타내고, 선은 간선을 나타내며, 노드 간의 부모-자식 관계를 시각적으로 표현합니다.

![Binary Tree Example](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/320px-Binary_tree.svg.png)

*   **루트 노드**: 가장 위에 있는 노드 (예: 이미지에서 최상단 노드)
*   **자식 노드**: 아래로 연결된 노드들
*   **리프 노드**: 더 이상 자식이 없는 노드 (예: 이미지에서 가장 아래쪽 노드들)

이러한 시각화를 통해 트리의 계층적 구조와 노드 간의 관계를 쉽게 파악할 수 있습니다.

---

### 5.6 트리 요약

| 항목       | 내용                                       |
| -------- | ---------------------------------------- |
| 자료 구조    | 비선형 자료구조 (계층적 구조)                        |
| 노드 연결 방식 | 부모-자식 관계                                 |
| 용도       | 파일 시스템, 탐색, 게임 AI, 경로 탐색 등               |
| 장점       | 빠른 탐색/삽입/삭제 (특히 이진 탐색 트리, 힙, AVL 등 활용 시) |
| 단점       | 배열/리스트보다 구현이 복잡할 수 있음                    |
| 순회 방법    | 전위, 중위, 후위, 레벨 순회 등 다양한 방식 가능            |

---

## 6. 이진 탐색 트리 (Binary Search Tree, BST)

### 6.1 이진 탐색 트리란?

이진 탐색 트리(BST)는 **이진 트리**의 일종으로, 다음과 같은 **규칙**을 따릅니다:

| 기준 노드(N)의 위치 기준 | 규칙                  |
| --------------- | ------------------- |
| 왼쪽 서브트리         | N보다 **작은 값들**만 존재   |
| 오른쪽 서브트리        | N보다 **큰 값들**만 존재    |
| 전체 서브트리 구조      | **모두 이진 탐색 트리여야 함** |

➡ **값을 비교하며 트리를 따라가면**,
👉 평균적으로 **탐색, 삽입, 삭제 모두 O(log n)**에 가능!

---

### 6.2 이진 탐색 트리 구조 예시

```plaintext
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
```

* **왼쪽**으로 갈수록 값이 작고
* **오른쪽**으로 갈수록 값이 큼
* 중위 순회하면 항상 **오름차순으로 정렬된 결과**

---

### 6.3 BST Python 구현

이진 탐색 트리의 핵심은 노드 삽입 시 정렬 규칙을 지키는 것입니다. 다음 Python 코드는 이진 탐색 트리의 `Node` 클래스와 `insert` 함수를 구현하여 BST를 생성하고, `inorder` 함수를 통해 올바르게 정렬되었는지 확인하는 예시입니다.

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None  # 왼쪽 자식 노드 (현재 노드보다 작은 값)
        self.right = None # 오른쪽 자식 노드 (현재 노드보다 큰 값)

# 값 삽입 함수
# 새로운 데이터를 이진 탐색 트리에 삽입합니다.
# 재귀적으로 호출되며, 적절한 위치를 찾아 노드를 추가합니다.
def insert(node, data):
    # 1. 베이스 케이스: 현재 노드가 None이면, 새로운 노드를 생성하여 반환합니다.
    #    이것이 새로운 노드가 삽입될 위치입니다.
    if node is None:
        return Node(data)
    
    # 2. 재귀 케이스: 삽입할 데이터와 현재 노드의 데이터를 비교합니다.
    if data < node.data:
        # 삽입할 데이터가 현재 노드보다 작으면 왼쪽 서브트리로 이동합니다.
        node.left = insert(node.left, data)
    else:
        # 삽입할 데이터가 현재 노드보다 크거나 같으면 오른쪽 서브트리로 이동합니다.
        # (일반적으로 BST는 중복 값을 허용하지 않지만, 허용한다면 오른쪽으로 보냅니다.)
        node.right = insert(node.right, data)
    
    # 변경된 노드(또는 새로 생성된 노드)를 반환하여 부모 노드와 연결합니다.
    return node

# 트리 생성
# 여러 값을 순차적으로 삽입하여 이진 탐색 트리를 구성합니다.
root = None # 초기 루트는 None으로 시작합니다.
for value in [8, 3, 10, 1, 6, 14, 4, 7, 13]:
    root = insert(root, value) # 각 값을 트리에 삽입합니다.

# 중위 순회 (Inorder Traversal) 함수
# 이진 탐색 트리에서 중위 순회는 항상 정렬된 순서로 노드를 방문합니다.
# (왼쪽 자식 -> 현재 노드 -> 오른쪽 자식)
def inorder(node):
    if node:
        inorder(node.left)  # 왼쪽 서브트리 방문
        print(node.data, end=' ') # 현재 노드 데이터 출력
        inorder(node.right) # 오른쪽 서브트리 방문

print("\n--- BST 중위 순회 결과 (오름차순 정렬) ---")
inorder(root)  # 출력: 1 3 4 6 7 8 10 13 14
print() # 줄바꿈을 위해 추가
```

---

### 6.4 BST 요약

| 항목     | 내용                                               |
| ------ | ------------------------------------------------ |
| 정렬 방식  | 이진 트리 + 정렬 규칙 (왼쪽 < 루트 < 오른쪽)                    |
| 시간 복잡도 | 평균: `O(log n)`, 최악: `O(n)` (편향되면)                |
| 공간 복잡도 | `O(n)` (재귀 호출, 노드 저장)                            |
| 장점     | ✔ 빠른 탐색, 삽입, 삭제 (중위 순회 시 오름차순 정렬 결과)             |
| 단점     | ❌ 트리 균형이 맞지 않으면 성능 저하 → `스케일에 따라 AVL/레드블랙 트리 고려` |
| 안정 정렬? | ❌ 보장하지 않음 (같은 값의 순서 유지 X)                        |

---

### 6.5 시각 자료

![이진 탐색 트리](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/320px-Binary_search_tree.svg.png)

---


## 7. 이진 탐색 트리의 순회 (Traversal)

이진 탐색 트리(BST)의 순회(Traversal)는 트리의 모든 노드를 체계적으로 방문하는 방법입니다. 순회 방식에 따라 트리의 구조를 이해하거나, 데이터를 정렬하거나, 삭제 등 다양한 작업에 활용됩니다. 대표적인 순회 방식은 **전위(Preorder)**, **중위(Inorder)**, **후위(Postorder)** 순회가 있습니다.

---
### 7.1 순회 종류와 특징


| 순회 방식         | 방문 순서         | 주요 용도                    |
| ------------- | ------------- | ------------------------ |
| 전위(Preorder)  | 루트 → 왼쪽 → 오른쪽 | 트리 복사, 직렬화               |
| 중위(Inorder)   | 왼쪽 → 루트 → 오른쪽 | 값 정렬 (BST에서 **오름차순 출력**) |
| 후위(Postorder) | 왼쪽 → 오른쪽 → 루트 | 트리 삭제, 자식부터 작업 수행 시      |

---
### 7.2 전위 순회 (Preorder Traversal)

- **방문 순서**: (1) 루트 → (2) 왼쪽 서브트리 → (3) 오른쪽 서브트리
- **특징**: 루트 노드를 가장 먼저 방문하므로 트리의 구조를 저장하거나 복사할 때 유용합니다. 예를 들어, 트리를 파일이나 네트워크로 전송할 때 직렬화(Serialization)하는 데 사용될 수 있습니다.
- **실행 흐름**:
    1.  현재 노드 방문 (데이터 처리)
    2.  왼쪽 자식 노드에 대해 재귀적으로 순회
    3.  오른쪽 자식 노드에 대해 재귀적으로 순회

```python
def preorder(node):
    if node:
        print(node.data, end=' ') # 1. 현재 노드의 데이터를 출력합니다.
        preorder(node.left)       # 2. 왼쪽 자식 노드에 대해 재귀적으로 전위 순회를 호출합니다.
        preorder(node.right)      # 3. 오른쪽 자식 노드에 대해 재귀적으로 전위 순회를 호출합니다.

# 예시 실행 (이전 BST 구현에서 생성된 'root' 노드를 사용합니다.)
# root = Node(8) ... (BST 구현 코드 참고)
print("\n--- 전위 순회 결과 ---")
preorder(root)  # 출력: 8 3 1 6 4 7 10 14 13
print() # 줄바꿈을 위해 추가
```

---
### 7.3 중위 순회 (Inorder Traversal)

- **방문 순서**: (1) 왼쪽 서브트리 → (2) 루트 → (3) 오른쪽 서브트리
- **특징**: 이진 탐색 트리에서 중위 순회를 하면 노드의 값이 **오름차순**으로 출력됩니다. 이는 BST의 핵심 속성 중 하나이며, 데이터를 정렬된 순서로 얻을 때 매우 유용합니다.
- **실행 흐름**:
    1.  왼쪽 자식 노드에 대해 재귀적으로 순회
    2.  현재 노드 방문 (데이터 처리)
    3.  오른쪽 자식 노드에 대해 재귀적으로 순회

```python
def inorder(node):
    if node:
        inorder(node.left)        # 1. 왼쪽 자식 노드에 대해 재귀적으로 중위 순회를 호출합니다.
        print(node.data, end=' ') # 2. 왼쪽 서브트리 방문이 끝나면 현재 노드의 데이터를 출력합니다.
        inorder(node.right)       # 3. 오른쪽 자식 노드에 대해 재귀적으로 중위 순회를 호출합니다.

# 예시 실행 (이전 BST 구현에서 생성된 'root' 노드를 사용합니다.)
# root = Node(8) ... (BST 구현 코드 참고)
print("\n--- 중위 순회 결과 (오름차순 정렬) ---")
inorder(root)  # 출력: 1 3 4 6 7 8 10 13 14
print() # 줄바꿈을 위해 추가
```
---
### 7.4 후위 순회 (Postorder Traversal)

- **방문 순서**: (1) 왼쪽 서브트리 → (2) 오른쪽 서브트리 → (3) 루트
- **특징**: 하위 노드를 모두 처리한 후 루트 노드를 방문하므로, 트리의 노드를 삭제하거나 하위 작업을 먼저 수행해야 할 때 사용합니다. 예를 들어, 디렉터리 구조에서 파일들을 먼저 삭제하고 그 다음에 빈 디렉터리를 삭제하는 경우에 유용합니다.
- **실행 흐름**:
    1.  왼쪽 자식 노드에 대해 재귀적으로 순회
    2.  오른쪽 자식 노드에 대해 재귀적으로 순회
    3.  현재 노드 방문 (데이터 처리)

```python
def postorder(node):
    if node:
        postorder(node.left)        # 1. 왼쪽 자식 노드에 대해 재귀적으로 후위 순회를 호출합니다.
        postorder(node.right)       # 2. 오른쪽 자식 노드에 대해 재귀적으로 후위 순회를 호출합니다.
        print(node.data, end=' ') # 3. 왼쪽, 오른쪽 서브트리 방문이 끝나면 현재 노드의 데이터를 출력합니다.

# 예시 실행 (이전 BST 구현에서 생성된 'root' 노드를 사용합니다.)
# root = Node(8) ... (BST 구현 코드 참고)
print("\n--- 후위 순회 결과 ---")
postorder(root)  # 출력: 1 4 7 6 3 13 14 10 8
print() # 줄바꿈을 위해 추가
```


---

### 7.5 순회 방식별 노드 방문 순서 비교

아래 BST 구조에서 각 순회 방식의 방문 순서는 다음과 같습니다.

```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
```

| 순회 방식        | 방문 순서                  | 설명                                      |
|------------------|---------------------------|-------------------------------------------|
| 전위(Preorder)   | 8 3 1 6 4 7 10 14 13      | 루트 → 왼쪽 → 오른쪽                      |
| 중위(Inorder)    | 1 3 4 6 7 8 10 13 14      | 왼쪽 → 루트 → 오른쪽 (오름차순 정렬)      |
| 후위(Postorder)  | 1 4 7 6 3 13 14 10 8      | 왼쪽 → 오른쪽 → 루트                      |

---

### 7.6 순회 방식의 시각적 이해

아래 그림은 이진 탐색 트리의 구조와 각 순회 방식의 방문 순서를 시각적으로 보여줍니다.

![이진 탐색 트리 예시](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/320px-Binary_search_tree.svg.png)

- **전위 순회**: 루트에서 시작해 왼쪽, 오른쪽 순으로 깊이 우선 탐색
- **중위 순회**: 가장 왼쪽 노드부터 오른쪽 노드까지 차례로 방문 (정렬 결과)
- **후위 순회**: 모든 자식 노드를 방문한 후 부모 노드를 방문

---

### 7.7 순회 방식의 활용 예시

- **전위 순회**: 트리 복사, 트리 구조 직렬화/역직렬화
- **중위 순회**: BST의 값 정렬, 범위 쿼리
- **후위 순회**: 트리 삭제, 하위 노드부터 처리하는 작업(예: 디렉터리 삭제)

---

### 7.8 참고: 순회 방식의 비재귀(스택) 구현

재귀 호출은 코드를 간결하게 만들지만, 재귀 깊이가 깊어질 경우 스택 오버플로우(Stack Overflow)의 위험이 있습니다. 이를 피하기 위해 반복문과 스택 자료구조를 사용하여 트리를 순회할 수도 있습니다. 다음은 중위 순회를 반복문과 스택으로 구현한 예시입니다.

```python
def inorder_iterative(node):
    stack = []      # 노드를 임시 저장할 스택을 초기화합니다.
    current = node  # 현재 방문 중인 노드를 추적하는 변수입니다.

    # 스택이 비어있지 않거나 현재 노드가 None이 아닐 때까지 반복합니다.
    # 이는 모든 노드를 방문할 때까지 루프를 계속하기 위함입니다.
    while stack or current:
        # 1. 현재 노드가 None이 아닐 동안, 왼쪽 자식 노드를 따라 계속 내려갑니다.
        #    이 과정에서 방문하는 모든 노드를 스택에 push합니다.
        while current:
            stack.append(current) # 현재 노드를 스택에 추가합니다.
            current = current.left # 현재 노드를 왼쪽 자식으로 이동합니다.
        
        # 2. 가장 깊은 왼쪽 노드에 도달하면, 스택에서 노드를 pop합니다.
        #    이 노드가 현재 서브트리에서 가장 작은 값(중위 순회 기준)을 가진 노드입니다.
        current = stack.pop()
        print(current.data, end=' ') # 해당 노드의 데이터를 출력합니다.
        
        # 3. 현재 노드의 오른쪽 자식으로 이동하여 다음 순회를 준비합니다.
        #    오른쪽 자식이 None이면 다음 루프에서 스택에서 다음 노드를 pop하게 됩니다.
        current = current.right

# 예시 실행 (이전 BST 구현에서 생성된 'root' 노드를 사용합니다.)
# root = Node(8) ... (BST 구현 코드 참고)
print("\n--- 중위 순회 (반복문 + 스택) 결과 ---")
inorder_iterative(root)  # 출력: 1 3 4 6 7 8 10 13 14
print() # 줄바꿈을 위해 추가
```
---
### 7.9 정리 요약

| 항목          | 전위 순회      | 중위 순회      | 후위 순회       |
| ----------- | ---------- | ---------- | ----------- |
| 순서          | 루트 → 좌 → 우 | 좌 → 루트 → 우 | 좌 → 우 → 루트  |
| 출력 결과 (BST) | 구조 복사용     | 정렬된 값      | 삭제 시 유용     |
| 핵심 사용 용도    | 트리 저장      | 값 정렬, 탐색   | 하위 노드 우선 작업 |

---

## 8. 이진 트리의 재귀 및 반복 순회 구현 상세

이진 트리의 순회는 트리의 모든 노드를 방문하는 체계적인 방법입니다. 크게 재귀적 방법과 반복적(Iterative) 방법으로 구현할 수 있으며, 각 방법은 특정 상황에서 장점을 가집니다.

### 8.1 재귀 순회 구현의 이해

재귀 순회는 함수의 호출 스택을 활용하여 트리를 탐색하는 가장 직관적인 방법입니다. 각 노드에서 자신을 처리하고, 왼쪽 자식과 오른쪽 자식에 대해 재귀적으로 동일한 함수를 호출합니다.

*   **전위 순회 (Preorder Traversal)**: `루트 -> 왼쪽 -> 오른쪽`
    *   현재 노드를 방문(처리)한 후, 왼쪽 서브트리를 재귀적으로 순회하고, 이어서 오른쪽 서브트리를 재귀적으로 순회합니다.
*   **중위 순회 (Inorder Traversal)**: `왼쪽 -> 루트 -> 오른쪽`
    *   왼쪽 서브트리를 재귀적으로 순회한 후, 현재 노드를 방문(처리)하고, 이어서 오른쪽 서브트리를 재귀적으로 순회합니다. 이진 탐색 트리(BST)의 경우 중위 순회 시 정렬된 순서로 노드를 방문하게 됩니다.
*   **후위 순회 (Postorder Traversal)**: `왼쪽 -> 오른쪽 -> 루트`
    *   왼쪽 서브트리를 재귀적으로 순회하고, 이어서 오른쪽 서브트리를 재귀적으로 순회한 후, 마지막으로 현재 노드를 방문(처리)합니다.

재귀 구현은 코드가 간결하고 이해하기 쉽지만, 트리의 깊이가 매우 깊어질 경우 스택 오버플로우(Stack Overflow)가 발생할 위험이 있습니다.

### 8.2 반복(Iterative) 순회 구현의 이해

반복 순회는 명시적인 스택 자료구조를 사용하여 재귀 호출 없이 트리를 탐색하는 방법입니다. 스택을 직접 관리함으로써 스택 오버플로우 위험을 줄일 수 있으며, 특정 상황에서는 재귀보다 성능상 이점을 가질 수 있습니다.

이전에 7.8에서 중위 순회의 반복 구현을 살펴보았습니다. 여기서는 전위 순회와 후위 순회의 반복 구현을 추가로 다룹니다.

### 8.3 반복 전위 순회 (Iterative Preorder Traversal)

반복 전위 순회는 스택을 사용하여 `루트 -> 왼쪽 -> 오른쪽` 순서로 노드를 방문합니다.

*   **알고리즘**:
    1.  현재 노드를 스택에 `push`합니다.
    2.  스택이 비어있지 않은 동안 다음을 반복합니다:
        a.  스택에서 노드를 `pop`하여 방문(처리)합니다.
        b.  `pop`된 노드의 오른쪽 자식이 있으면 스택에 `push`합니다. (오른쪽을 먼저 `push`해야 왼쪽이 먼저 `pop`됩니다.)
        c.  `pop`된 노드의 왼쪽 자식이 있으면 스택에 `push`합니다.

```python
# Node 클래스는 이미 정의되어 있다고 가정합니다.
# class Node:
#     def __init__(self, data):
#         self.data = data
#         self.left = None
#         self.right = None

def iterative_preorder(root):
    if not root:
        return

    stack = []
    stack.append(root) # 루트 노드를 스택에 추가

    print("\n--- 반복 전위 순회 결과 ---")
    while stack:
        node = stack.pop() # 스택에서 노드를 꺼내 방문
        print(node.data, end=' ')

        # 오른쪽 자식을 먼저 스택에 넣어야 왼쪽 자식이 먼저 처리됨
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)
    print()

# 예시 실행 (이전 BST 구현에서 생성된 'root' 노드를 사용합니다.)
# root = Node(8) ... (BST 구현 코드 참고)
# iterative_preorder(root) # 출력: 8 3 1 6 4 7 10 14 13
```

### 8.4 반복 후위 순회 (Iterative Postorder Traversal)

반복 후위 순회는 `왼쪽 -> 오른쪽 -> 루트` 순서로 노드를 방문하며, 다른 순회 방식보다 구현이 다소 복잡할 수 있습니다. 일반적으로 두 개의 스택을 사용하거나, 하나의 스택과 이전 방문 노드를 추적하는 방식으로 구현합니다. 여기서는 두 개의 스택을 사용하는 방법을 소개합니다.

*   **알고리즘 (두 개의 스택 사용)**:
    1.  첫 번째 스택(`s1`)에 루트 노드를 `push`합니다.
    2.  `s1`이 비어있지 않은 동안 다음을 반복합니다:
        a.  `s1`에서 노드를 `pop`하여 두 번째 스택(`s2`)에 `push`합니다.
        b.  `pop`된 노드의 왼쪽 자식이 있으면 `s1`에 `push`합니다.
        c.  `pop`된 노드의 오른쪽 자식이 있으면 `s1`에 `push`합니다.
    3.  `s2`에 있는 모든 노드를 `pop`하여 방문(처리)합니다. `s2`에 노드가 `push`되는 순서가 `루트 -> 오른쪽 -> 왼쪽`이므로, `pop`되는 순서는 `왼쪽 -> 오른쪽 -> 루트`가 됩니다.

```python
# Node 클래스는 이미 정의되어 있다고 가정합니다.
# class Node:
#     def __init__(self, data):
#         self.data = data
#         self.left = None
#         self.right = None

def iterative_postorder(root):
    if not root:
        return

    s1 = [] # 첫 번째 스택
    s2 = [] # 두 번째 스택 (결과를 역순으로 저장)

    s1.append(root) # 루트 노드를 첫 번째 스택에 추가

    while s1:
        node = s1.pop() # s1에서 노드를 꺼내 s2에 추가
        s2.append(node)

        # 왼쪽 자식을 먼저 s1에 넣어야 s2에 나중에 들어가고, 최종적으로 먼저 pop됨
        if node.left:
            s1.append(node.left)
        if node.right:
            s1.append(node.right)
    
    print("\n--- 반복 후위 순회 결과 ---")
    while s2:
        node = s2.pop() # s2에서 노드를 꺼내 방문 (후위 순서)
        print(node.data, end=' ')
    print()

# 예시 실행 (이전 BST 구현에서 생성된 'root' 노드를 사용합니다.)
# root = Node(8) ... (BST 구현 코드 참고)
# iterative_postorder(root) # 출력: 1 4 7 6 3 13 14 10 8
```

---

## 9. 이진 트리의 배열 표현

이진 트리는 노드 기반의 연결 구조 외에도 배열을 사용하여 효율적으로 표현할 수 있습니다. 특히 완전 이진 트리(Complete Binary Tree)나 포화 이진 트리(Full Binary Tree)와 같이 노드가 특정 규칙에 따라 채워지는 경우 배열 표현이 매우 유용합니다.

### 9.1. 배열 구조 및 인덱스 계산

이진 트리를 배열로 표현할 때는 일반적으로 루트 노드를 배열의 첫 번째 인덱스(0 또는 1)에 배치하고, 자식 노드들을 특정 규칙에 따라 배열에 순차적으로 저장합니다. 다음은 인덱스 0부터 시작하는 배열 표현의 예시입니다.

![이진트리 배열](https://wikidocs.net/images/page/193817/fig-044.png)

| 인덱스 | 0 | 1 | 2 | 3 | 4 | 5 | 6    | 7 |
|--------|---|---|---|---|---|---|------|---|
|   값   | A | B | C | D | E | F | None | G |

배열을 사용해 이진 트리를 나타낼 때, 각 노드의 인덱스에 따른 부모 노드와 자식 노드의 인덱스를 다음 규칙으로 계산할 수 있습니다.

*   **부모 노드가 인덱스 `n`일 때**:
    *   왼쪽 자식 노드의 인덱스: `2 × n + 1`
    *   오른쪽 자식 노드의 인덱스: `2 × n + 2`
*   **자식 노드가 인덱스 `n`일 때**:
    *   부모 노드의 인덱스: `(n - 1) // 2` (정수 나눗셈)

**예시**: 위 트리 구조에서 인덱스 계산

*   **A (루트)**의 인덱스는 0:
    *   왼쪽 자식 B의 인덱스: `2 × 0 + 1 = 1`
    *   오른쪽 자식 C의 인덱스: `2 × 0 + 2 = 2`
*   **B**의 인덱스는 1:
    *   왼쪽 자식 D의 인덱스: `2 × 1 + 1 = 3`
    *   오른쪽 자식 E의 인덱스: `2 × 1 + 2 = 4`
*   **C**의 인덱스는 2:
    *   왼쪽 자식 F의 인덱스: `2 × 2 + 1 = 5`
*   **D**의 인덱스는 3:
    *   왼쪽 자식 G의 인덱스: `2 × 3 + 1 = 7`

**참고**: 인덱스 0을 비워두고 인덱스 1부터 자료를 넣어 트리를 구성하는 경우도 있습니다. 이 경우 왼쪽 자식 노드의 인덱스는 `(2 × n)`, 오른쪽 자식 노드의 인덱스는 `(2 × n + 1)`이 되며, 부모 노드의 인덱스는 자식 노드의 인덱스를 2로 나눈 몫(`n // 2`)이 됩니다.

### 9.2. 자식 노드와 부모 노드 찾기 구현

배열로 표현된 이진 트리에서 특정 노드의 자식 노드나 부모 노드를 찾는 Python 코드 예시입니다.

#### 9.2.1. 자식 노드 찾기

```python
tree = ["A", "B", "C", "D", "E", "F", None, "G"]

n = len(tree)
for i in range(n):
    if tree[i] is not None:  # 현재 노드가 None이 아닐 때만 처리
        print(f"Parent: {tree[i]}", end=", ")
        left_child_idx = 2 * i + 1  # 왼쪽 자식 노드의 예상 인덱스
        right_child_idx = 2 * i + 2 # 오른쪽 자식 노드의 예상 인덱스

        # 왼쪽 자식이 배열 범위 안에 있고 None이 아닐 때 출력
        if left_child_idx < n and tree[left_child_idx] is not None:
            print(f"Left: {tree[left_child_idx]}", end=", ")
        # 오른쪽 자식이 배열 범위 안에 있고 None이 아닐 때 출력
        if right_child_idx < n and tree[right_child_idx] is not None:
            print(f"Right: {tree[right_child_idx]}", end=" ")
        print()
```

**실행 결과**

```
Parent: A, Left: B, Right: C 
Parent: B, Left: D, Right: E 
Parent: C, Left: F, 
Parent: D, Left: G, 
Parent: E, 
Parent: F, 
Parent: G, 
```

#### 9.2.2. 부모 노드 찾기

```python
tree = ["A", "B", "C", "D", "E", "F", None, "G"]

n = len(tree)
# 부모 노드 찾기 (루트 노드(인덱스 0)는 부모가 없으므로 인덱스 1부터 순회)
for i in range(1, n):
    if tree[i] is not None:
        parent_idx = (i - 1) // 2 # 부모 노드의 인덱스 계산
        print(f"Parent of {tree[i]} -> {tree[parent_idx]}")
```

**실행 결과**

```
Parent of B -> A
Parent of C -> A
Parent of D -> B
Parent of E -> B
Parent of F -> C
Parent of G -> D
```

---

## 10. 트리를 이용한 전위, 중위, 후위 계산 방법

트리 구조(특히 이진 트리)를 이용하면 전위, 중위, 후위 순회 방식으로 수식의 값을 계산할 수 있습니다. 각 순회 방식은 수식의 표기법(전위: Prefix, 중위: Infix, 후위: Postfix)과 밀접하게 연관되어 있습니다.

### 10.1. 이진 트리에서의 수식 표현 및 노드 정의

수식을 이진 트리로 표현할 때, 연산자는 부모 노드가 되고 피연산자(숫자)는 자식 노드가 됩니다. 예를 들어, 수식 `3 + (4 * 5)`를 이진 트리로 표현하면 다음과 같습니다.

```
    +
   / \
  3   *
     / \
    4   5
```

이러한 수식 트리를 다루기 위한 `Node` 클래스는 다음과 같이 정의할 수 있습니다.

```python
class Node:
    def __init__(self, data):
        self.data = data  # 노드가 저장할 데이터 (연산자 또는 숫자)
        self.left = None  # 왼쪽 자식 노드
        self.right = None # 오른쪽 자식 노드
```

위 트리 구조에서 각 순회 방식에 따른 수식 표기법은 다음과 같습니다:

*   **전위(Prefix) 표기법**: 연산자를 먼저 방문 → `+ 3 * 4 5`
*   **중위(Infix) 표기법**: 연산자를 가운데 방문 → `3 + 4 * 5`
*   **후위(Postfix) 표기법**: 연산자를 마지막에 방문 → `3 4 5 * +`

### 10.2. 순회별 계산 방법 및 구현

각 순회 방식에 따라 수식 트리를 탐색하며 값을 계산하는 방법은 다음과 같습니다.

#### 10.2.1. 전위 순회(Prefix) 계산

전위 순회는 연산자를 먼저 처리하는 방식입니다. 수식 트리에서는 루트 노드(연산자)를 먼저 방문하고, 그 다음 왼쪽 자식과 오른쪽 자식을 재귀적으로 방문하여 값을 계산합니다.

*   **계산 원리**: 
    1.  현재 노드가 연산자(`+`, `-`, `*`, `/`)이면, 왼쪽 자식과 오른쪽 자식에 대해 재귀적으로 `eval_prefix` 함수를 호출하여 피연산자들의 값을 얻습니다.
    2.  얻은 두 피연산자 값에 대해 현재 노드의 연산자를 적용하여 결과를 반환합니다.
    3.  현재 노드가 숫자이면, 그 값을 정수로 변환하여 반환합니다.

```python
def eval_prefix(node):
    if node is None:
        return 0 # 유효하지 않은 노드일 경우 0 반환 (또는 에러 처리)

    # 노드의 데이터가 연산자인지 확인합니다.
    if node.data in '+-*/':
        # 왼쪽 자식과 오른쪽 자식에 대해 재귀적으로 함수를 호출하여 값을 얻습니다.
        left_val = eval_prefix(node.left)
        right_val = eval_prefix(node.right)

        # 현재 노드의 연산자에 따라 해당 연산을 수행합니다.
        if node.data == '+':
            return left_val + right_val
        elif node.data == '-':
            return left_val - right_val
        elif node.data == '*':
            return left_val * right_val
        elif node.data == '/':
            # 0으로 나누는 경우를 방지하기 위한 간단한 처리
            if right_val == 0:
                raise ValueError("Division by zero")
            return left_val / right_val
    else:
        # 노드의 데이터가 숫자이면 정수로 변환하여 반환합니다.
        return int(node.data)
```

#### 10.2.2. 중위 순회(Infix) 계산

중위 순회는 연산자를 피연산자 사이에 두는 방식입니다. 일반적인 수학 수식 표기법과 동일합니다.

*   **계산 원리**:
    *   실제 계산은 연산자 우선순위에 따라 괄호를 고려해야 하므로, 트리 구조를 이용하면 중위 순회만으로는 수식의 계산이 직접적으로 이루어지지 않습니다.
    *   중위 순회는 주로 수식을 사람이 읽기 좋은 형태(중위 표기법)로 변환할 때 사용하며, 계산은 후위 또는 전위 순회를 통해 수행하는 것이 일반적입니다. 중위 표기법으로 변환된 수식은 별도의 파싱 과정을 거쳐야 계산할 수 있습니다.

#### 10.2.3. 후위 순회(Postfix) 계산

후위 순회는 피연산자를 먼저 처리하고 연산자를 나중에 처리하는 방식입니다. 스택을 사용하여 효율적으로 계산할 수 있습니다.

*   **계산 원리**:
    1.  현재 노드가 연산자(`+`, `-`, `*`, `/`)이면, 왼쪽 자식과 오른쪽 자식에 대해 재귀적으로 `eval_postfix` 함수를 호출하여 피연산자들의 값을 얻습니다.
    2.  얻은 두 피연산자 값에 대해 현재 노드의 연산자를 적용하여 결과를 반환합니다.
    3.  현재 노드가 숫자이면, 그 값을 정수로 변환하여 반환합니다.

```python
def eval_postfix(node):
    if node is None:
        return 0 # 유효하지 않은 노드일 경우 0 반환 (또는 에러 처리)

    # 노드의 데이터가 연산자인지 확인합니다.
    if node.data in '+-*/':
        # 왼쪽 자식과 오른쪽 자식에 대해 재귀적으로 함수를 호출하여 값을 얻습니다.
        # 후위 순회이므로 자식 노드의 값을 먼저 계산합니다.
        left_val = eval_postfix(node.left)
        right_val = eval_postfix(node.right)

        # 현재 노드의 연산자에 따라 해당 연산을 수행합니다.
        if node.data == '+':
            return left_val + right_val
        elif node.data == '-':
            return left_val - right_val
        elif node.data == '*':
            return left_val * right_val
        elif node.data == '/':
            # 0으로 나누는 경우를 방지하기 위한 간단한 처리
            if right_val == 0:
                raise ValueError("Division by zero")
            return left_val / right_val
    else:
        # 노드의 데이터가 숫자이면 정수로 변환하여 반환합니다.
        return int(node.data)
```

### 10.3. 전체 예시: 수식 트리 구축 및 계산

수식 `3 + (4 * 5)`에 대한 이진 트리를 구축하고, `eval_prefix`와 `eval_postfix` 함수를 사용하여 계산하는 전체 예시입니다.

```python
# Node 클래스 정의 (수식 트리에 사용)
class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

# 수식 트리 구축: 3 + (4 * 5)
# 루트 노드: +
root_expr = Node('+')

# 왼쪽 자식: 3
root_expr.left = Node('3')

# 오른쪽 자식: *
root_expr.right = Node('*')
root_expr.right.left = Node('4')
root_expr.right.right = Node('5')

# 전위 순회(Prefix) 계산 함수
def eval_prefix(node):
    if node is None:
        return 0
    if node.data in '+-*/':
        left_val = eval_prefix(node.left)
        right_val = eval_prefix(node.right)
        if node.data == '+': return left_val + right_val
        elif node.data == '-': return left_val - right_val
        elif node.data == '*': return left_val * right_val
        elif node.data == '/':
            if right_val == 0: raise ValueError("Division by zero")
            return left_val / right_val
    else:
        return int(node.data)

# 후위 순회(Postfix) 계산 함수
def eval_postfix(node):
    if node is None:
        return 0
    if node.data in '+-*/':
        left_val = eval_postfix(node.left)
        right_val = eval_postfix(node.right)
        if node.data == '+': return left_val + right_val
        elif node.data == '-': return left_val - right_val
        elif node.data == '*': return left_val * right_val
        elif node.data == '/':
            if right_val == 0: raise ValueError("Division by zero")
            return left_val / right_val
    else:
        return int(node.data)

print(f"수식 3 + (4 * 5)의 전위 순회 계산 결과: {eval_prefix(root_expr)}") # 출력: 23
print(f"수식 3 + (4 * 5)의 후위 순회 계산 결과: {eval_postfix(root_expr)}") # 출력: 23
```

위 예시에서 볼 수 있듯이, 전위 순회와 후위 순회는 수식 트리를 이용하여 복잡한 수식을 효율적으로 계산하는 데 활용될 수 있습니다. 중위 순회는 주로 수식의 표현을 위해 사용되며, 계산을 위해서는 별도의 파싱 로직이 필요합니다.

- **전위/후위 순회**를 이용하면 트리 구조에서 수식의 값을 쉽게 계산할 수 있습니다.
- 각 노드를 방문할 때 연산자라면 자식 노드의 값을 계산하여 연산을 수행합니다.
- 트리 구조는 복잡한 수식의 계산, 컴파일러의 파싱, 계산기 구현 등에 널리 활용됩니다.

---
## 11. 트리와 이진 탐색 트리 비교

일반 트리와 이진 탐색 트리는 모두 계층적 자료구조이지만, 중요한 차이점이 있습니다. 다음 표는 두 자료구조의 주요 특징을 비교하여 보여줍니다.

| 항목           | 일반 트리 (Tree)                     | 이진 탐색 트리 (Binary Search Tree) |
| :----------- | :----------------------------------- | :---------------------------------- |
| **구조**       | 계층적 노드 구조 (자식 수 제한 없음) | 각 노드가 최대 두 개의 자식 노드 가짐        |
| **노드 규칙**    | 특별한 규칙 없음                     | 왼쪽 자식: 작은 값, 오른쪽 자식: 큰 값      |
| **정렬 규칙**    | 없음                                 | 왼쪽 < 루트 < 오른쪽                 |
| **용도**       | 계층 구조 표현 (파일 시스템, 조직도 등) | 빠른 탐색, 삽입, 삭제                 |
| **탐색 속도**    | 구조에 따라 다름 (비효율적일 수 있음) | 평균 O(log n), 최악 O(n)          |
| **중복 허용 여부** | 보통 허용                            | 보통 중복값을 허용하지 않음 (설계에 따라 다름)   |
| **순회 결과 의미** | 의미 없음 (용도에 따라 다름)         | 중위 순회 → 오름차순 정렬된 값 출력         |
| **대표 예시**    | 조직도, DOM 트리, 폴더 구조 등       | 데이터베이스 인덱스, 탐색 알고리즘           |
---
[⏮️ 이전 문서](./0604_Algorithm정리.md) | [다음 문서 ⏭️](./0609_Algorithm정리.md)