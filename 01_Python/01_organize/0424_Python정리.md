# 🐍 Python 기초 심화: 문자열과 리스트 (Day 2)

> **이 문서의 목적**: 이 문서는 부트캠프 2일차에 학습한 Python의 핵심 자료 구조인 **문자열 (String)  **과 **리스트(List)**에 대해 심도 있게 정리한 자료입니다. 각 자료형의 특징, 주요 메서드, 그리고 실용적인 활용법을 상세한 예제와 함께 다루어, 데이터 처리의 기본기를 탄탄히 다지는 것을 목표로 합니다.

---

## 목차

1.  [**Python의 핵심 자료 구조**](#1-python의-핵심-자료-구조)
    -   [데이터 타입 복습 및 분류](#데이터-타입-복습-및-분류)
2.  [**문자열(String) 다루기**](#2-문자열string-다루기)
    -   [문자열의 기본](#문자열의-기본)
    -   [인덱싱과 슬라이싱: 원하는 부분만 정확하게](#인덱싱과-슬라이싱-원하는-부분만-정확하게)
    -   [문자열 포매팅: f-string 활용](#문자열-포매팅-f-string-활용)
    -   [자주 사용하는 문자열 메서드](#자주-사용하는-문자열-메서드)
3.  [**리스트(List): 순차적 데이터 관리**](#3-리스트list-순차적-데이터-관리)
    -   [리스트의 특징: 순서가 있고, 변경 가능하다](#리스트의-특징-순서가-있고-변경-가능하다)
    -   [리스트의 생성과 조작](#리스트의-생성과-조작)
    -   [리스트 컴프리헨션: 간결한 리스트 생성](#리스트-컴프리헨션-간결한-리스트-생성)
4.  [**[심화] 컴퓨터의 숫자 표현 방식**](#4-심화-컴퓨터의-숫자-표현-방식)
    -   [2진수, 8진수, 16진수 변환](#2진수-8진수-16진수-변환)
    -   [Python을 이용한 진수 변환](#python을-이용한-진수-변환)

---

## 1. Python의 핵심 자료 구조

Python은 데이터를 효율적으로 다루기 위한 여러 내장 자료 구조를 제공합니다. 각 자료 구조의 특징을 이해하고 상황에 맞게 사용하는 것이 중요합니다.

### 데이터 타입 복습 및 분류

| 구분 | 자료형 | 특징 | 변경 가능성 (Mutability) | 예시 |
| :--- | :--- | :--- | :--- | :--- |
| **단일 값** | `int`, `float`, `bool` | 숫자, 참/거짓 등 하나의 값을 저장 | **Immutable** (변경 불가) | `10`, `3.14`, `True` |
| **시퀀스** | `str` (문자열) | 문자의 순차적 나열 | **Immutable** (변경 불가) | `"Hello"` |
| | `list` (리스트) | 여러 타입 데이터의 순차적 나열 | **Mutable** (변경 가능) | `[1, "apple", True]` |
| | `tuple` (튜플) | 리스트와 유사하나, **변경 불가** | **Immutable** (변경 불가) | `(1, "apple", True)` |
| **매핑** | `dict` (딕셔너리) | Key-Value 쌍으로 데이터를 저장 | **Mutable** (변경 가능) | `{'name': 'Alice', 'age': 25}` |
| **집합** | `set` (세트) | **중복을 허용하지 않는** 순서 없는 데이터 모음 | **Mutable** (변경 가능) | `{'A', 'B', 'C'}` |

> **💡 Mutability (변경 가능성) 란?**
> -   **Mutable (변경 가능)**: 객체가 생성된 후에 그 내용을 수정할 수 있습니다. `list`에 원소를 추가하거나 삭제하는 것이 해당됩니다.
> -   **Immutable (변경 불가)**: 객체가 생성된 후에는 그 내용을 바꿀 수 없습니다. 문자열의 한 글자를 바꾸려고 하면 오류가 발생하는 이유입니다. `name = "Tom"`, `name[0] = "J"` (X)

---

## 2. 문자열(String) 다루기

문자열은 텍스트 데이터를 처리하는 데 사용되는 가장 기본적인 자료형입니다.

### 문자열의 기본

-   **생성**: 작은따옴표(`'`)나 큰따옴표(`"`)로 감싸서 생성합니다. 여러 줄 문자열은 따옴표 세 개(`'''` 또는 `"""`)를 사용합니다.
-   **Immutable**: 한 번 생성된 문자열의 내용은 변경할 수 없습니다.

### 인덱싱과 슬라이싱: 원하는 부분만 정확하게

-   **인덱싱(Indexing)**: 특정 위치의 문자 하나를 가리킵니다.
-   **슬라이싱(Slicing)**: `[start:stop:step]` 형태로 특정 범위의 부분 문자열을 추출합니다.

```python
#         P  y  t  h  o  n
# 정방향:  0  1  2  3  4  5
# 역방향: -6 -5 -4 -3 -2 -1
text = "Python"

# 인덱싱
print(f"첫 글자: {text[0]}")      # 출력: P
print(f"마지막 글자: {text[-1]}") # 출력: n

# 슬라이싱
print(f"1번부터 4번 앞까지: {text[1:4]}") # 출력: yth
print(f"처음부터 2번 앞까지: {text[:2]}")  # 출력: Py
print(f"3번부터 끝까지: {text[3:]}")      # 출력: hon
print(f"전체 문자열: {text[:]}")         # 출력: Python

# Step을 이용한 슬라이싱
print(f"두 칸씩 건너뛰기: {text[::2]}") # 출력: Pto
print(f"역순으로 뒤집기: {text[::-1]}") # 출력: nohtyP
```

### 문자열 포매팅: f-string 활용

변수와 문자열을 조합할 때, **f-string (formatted string literal)**을 사용하는 것이 가장 현대적이고 가독성이 좋습니다.

```python
name = "Alice"
age = 25

# 과거 방식: + 연산자 (가독성이 떨어지고, 비문자열은 str() 변환 필요)
greeting_old = name + " is " + str(age) + " years old."

# 현대 방식: f-string (직관적이고 깔끔함)
greeting_new = f"{name} is {age} years old."

print(greeting_old)
print(greeting_new)
```

### 자주 사용하는 문자열 메서드

문자열은 `Immutable`이므로, 메서드를 사용하면 **새로운 문자열이 반환**됩니다. 기존 문자열은 변하지 않습니다.

| 메서드 | 설명 | 예시 (`s = "  Hello, Python!  "`) | 결과 |
| :--- | :--- | :--- | :--- |
| `s.upper()` | 모든 문자를 대문자로 변경 | `s.upper()` | `"  HELLO, PYTHON!  "` |
| `s.lower()` | 모든 문자를 소문자로 변경 | `s.lower()` | `"  hello, python!  "` |
| `s.strip()` | 양쪽 끝의 공백 및 특정 문자 제거 | `s.strip()` | `"Hello, Python!"` |
| `s.replace(old, new)` | `old` 문자열을 `new`로 교체 | `s.replace("Python", "World")` | `"  Hello, World!  "` |
| `s.split(sep)` | `sep`을 기준으로 문자열을 나눠 **리스트**로 반환 | `s.strip().split(',')` | `['Hello', ' Python!']` |
| `s.find(sub)` | `sub` 문자열이 처음 나타나는 인덱스 반환 (없으면 -1) | `s.find("Python")` | `9` |
| `s.count(sub)` | `sub` 문자열이 나타나는 횟수 반환 | `s.count("l")` | `2` |
| `''.join(iterable)` | 리스트 등의 원소를 합쳐 하나의 문자열로 만듦 | `'-'.join(['a', 'b', 'c'])` | `"a-b-c"` |

---

## 3. 리스트(List): 순차적 데이터 관리

리스트는 여러 데이터를 순서대로 저장하고, 자유롭게 수정, 추가, 삭제할 수 있는 매우 유연한 자료 구조입니다.

### 리스트의 특징: 순서가 있고, 변경 가능하다

-   **순서(Sequence)**: 데이터가 저장된 순서가 유지됩니다. 인덱스로 접근할 수 있습니다.
-   **변경 가능(Mutable)**: 생성된 후에도 원소를 추가, 수정, 삭제할 수 있습니다.
-   **다양한 타입 저장**: 숫자, 문자열, 다른 리스트 등 어떤 타입의 데이터도 함께 저장할 수 있습니다.

### 리스트의 생성과 조작

```python
# 리스트 생성
fruits = ["apple", "banana", "cherry"]

# 인덱싱 및 슬라이싱 (문자열과 동일)
first_fruit = fruits[0]
some_fruits = fruits[1:3] # ['banana', 'cherry']

# 원소 변경 (Mutable)
fruits[0] = "avocado"
print(f"리스트 변경 후: {fruits}") # ['avocado', 'banana', 'cherry']
```

#### 주요 리스트 메서드

| 메서드 | 설명 | 예시 (`nums = [1, 3, 5]`) | 결과 |
| :--- | :--- | :--- | :--- |
| `nums.append(x)` | 리스트 **끝**에 원소 `x`를 추가 | `nums.append(7)` | `[1, 3, 5, 7]` |
| `nums.insert(i, x)` | 인덱스 `i`에 원소 `x`를 삽입 | `nums.insert(1, 2)` | `[1, 2, 3, 5]` |
| `nums.remove(x)` | 리스트에서 첫 번째로 나타나는 `x`를 제거 | `nums.remove(3)` | `[1, 5]` |
| `nums.pop(i)` | 인덱스 `i`의 원소를 **반환하고** 제거 (i 생략 시 마지막 원소) | `popped = nums.pop(0)` | `popped`는 `1`, `nums`는 `[3, 5]` |
| `nums.sort()` | 원본 리스트를 오름차순으로 정렬 | `nums.sort(reverse=True)` | `[5, 3, 1]` |
| `len(nums)` | 리스트의 길이(원소 개수) 반환 | `len(nums)` | `3` |

### 리스트 컴프리헨션: 간결한 리스트 생성

`for` 루프를 사용하여 리스트를 만드는 과정을 한 줄로 간결하게 표현할 수 있습니다. 가독성이 좋고 처리 속도도 빠릅니다.

```python
# 일반적인 방법
squares_old = []
for i in range(5): # 0부터 4까지
    squares_old.append(i * i)
# 결과: [0, 1, 4, 9, 16]

# 리스트 컴프리헨션
# [표현식 for 항목 in 반복가능객체]
squares_new = [i * i for i in range(5)]
# 결과: [0, 1, 4, 9, 16]

# 조건문을 포함한 컴프리헨션
# 0~9 중 짝수만 제곱하여 리스트로 만들기
even_squares = [x**2 for x in range(10) if x % 2 == 0]
# 결과: [0, 4, 16, 36, 64]
```

---

## 4. [심화] 컴퓨터의 숫자 표현 방식

컴퓨터는 모든 데이터를 0과 1의 조합인 **2진수**로 처리합니다. 8진수와 16진수는 2진수를 사람이 더 읽기 쉽게 표현하기 위해 사용됩니다.

### 2진수, 8진수, 16진수 변환

-   **2진수 → 8진수**: 2진수를 뒤에서부터 **3비트**씩 묶어 변환합니다.
-   **2진수 → 16진수**: 2진수를 뒤에서부터 **4비트**씩 묶어 변환합니다. (0-9, A-F)

| 10진수 | 2진수 | 8진수 | 16진수 |
| :---: | :---: | :---: | :---: |
| 10 | `1010` | `12` | `A` |
| 13 | `1101` | `15` | `D` |
| 16 | `10000` | `20` | `10` |

### Python을 이용한 진수 변환

Python은 진수 변환을 위한 내장 함수를 제공하여 편리하게 변환 작업을 수행할 수 있습니다.

```python
decimal_num = 26

# 10진수 -> 2, 8, 16진수 (결과는 문자열)
print(f"10진수 {decimal_num} -> 2진수: {bin(decimal_num)}")   # 0b11010
print(f"10진수 {decimal_num} -> 8진수: {oct(decimal_num)}")   # 0o32
print(f"10진수 {decimal_num} -> 16진수: {hex(decimal_num)}")  # 0x1a

# 2, 8, 16진수 문자열 -> 10진수
binary_str = "0b11010"
octal_str = "0o32"
hex_str = "0x1a"

# int(문자열, 밑) 함수를 사용
print(f"2진수 {binary_str} -> 10진수: {int(binary_str, 2)}") # 26
print(f"8진수 {octal_str} -> 10진수: {int(octal_str, 8)}") # 26
print(f"16진수 {hex_str} -> 10진수: {int(hex_str, 16)}") # 26
```

---

[⏮️ 이전 문서](./0423_Python정리.md) | [다음 문서 ⏭️](./0425_Python정리.md)
